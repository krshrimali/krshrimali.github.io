<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 | Kushashwa Ravi Shrimali (Kush)</title>
<meta name="keywords" content="computer vision, python, portrait bokeh, image processing">
<meta name="description" content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:

The face cropped was a rectangle, and it was clearly visible in the output result.

To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition.">
<meta name="author" content="map[name:Kushashwa Ravi Shrimali]">
<link rel="canonical" href="https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/">
<link crossorigin="anonymous" href="https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://krshrimali.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://krshrimali.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://krshrimali.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://krshrimali.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://krshrimali.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/">
  <meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)">
  <meta property="og:title" content="How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2">
  <meta property="og:description" content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:
The face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of “some” of the background noise we got earlier, for Portrait Bokeh. Let’s take this step by step, and first talk about the intuition.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-12-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-12-10T00:00:00+00:00">
    <meta property="article:tag" content="Computer Vision">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Portrait Bokeh">
    <meta property="article:tag" content="Image Processing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2">
<meta name="twitter:description" content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:

The face cropped was a rectangle, and it was clearly visible in the output result.

To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://krshrimali.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2",
      "item": "https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2",
  "name": "How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2",
  "description": "\nHi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:\nThe face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of \u0026ldquo;some\u0026rdquo; of the background noise we got earlier, for Portrait Bokeh. Let\u0026rsquo;s take this step by step, and first talk about the intuition.\n",
  "keywords": [
    "computer vision", "python", "portrait bokeh", "image processing"
  ],
  "articleBody": "\nHi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:\nThe face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of “some” of the background noise we got earlier, for Portrait Bokeh. Let’s take this step by step, and first talk about the intuition.\nIntuition behind cropping a circle while pixels are just the brightness values for each channel at a particular coordinate, so you can’t really get half of the pixel and crop an exact circle. But the closest we can get to cropping a circle, is to imagine a circle circumscribed in a rectangle (face detection algorithm in OpenCV - CascadeClassifier returns a rectangle - can be a square as well). So if we are able to get a circle from our output of face detection (a rectangle), we will be closer to what we want.\nBut how do we get started? Clearly, since the circle is circumscribing the rectangle, the closest we can get to finding radius is: max(width, height)/2. While center will be: (top_left_x + width/2, top_left_y + height/2). Once we know these two properties of the circle, we will now have the circle equation.\nMethodology Let’s divide this problem statement into steps:\nGet face from Face Detection. Get circle circumscribing the face (rectangle). Crop the circle and store it in different array. Blur the whole image except the face. Essentially, the main goal is to get the face cropped as a circle. Once we have that, we can simply overlay this on the blurred image. The trick is to figure out on how we can crop the circle once we know it’s coordinates. Let’s talk about it’s solution in the next section.\nCropping a circle Usually, our images will have 3 channels (colored image): Blue, Green, Red (BGR). How about we add a transparency channel to our image? The idea behind this is to make all pixels transparent which are NOT in the face, and all the pixels opaque which are within/on the face (circle) boundary. The pseudo code for this should look something like this:\n# Assuming you got a circle equation representing the face face = circle_equation # Now iterate through all the pixel values in the imagge # Check if the pixel is outside the face, if yes - then make it transparent # Else - opaque for pixel_value in image: if pixel_value is outside the face: # Make this pixel transparent else: # Make this pixel opaque # This will be visible To have an option to add transparency, you need to convert the BGR input image to BGRA (4 channel image: Blue, Green, Red, Alpha) - here Alpha channel denotes transparency channel. When the transparency is set to 0, that represents opaque and when it’s set to 255, it represents transparent value. Let’s go ahead and use this for our application.\nVideo Tutorial I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven’t seen it before, please check it out here. For this blog, I have already uploaded a detailed tutorial. Check it out here.\nStep 1: Get face from face detection We have discussed this before, so we won’t go in details but for the sake of continuity, I’ll add the code for Face Detection.\nimport cv2, sys # Get image path and read image img_path = sys.argv[1] if len(sys.argv) \u003e 1 else \"sample.png\" img = cv2.imread(img_path, 1) # Convert to grayscale, since Face Detection takes gray scale image as input gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Initialize face detector from the model file face_detector = cv2.CascadeClassifier(\"haarcascade_frontalface_default.xml\") # Detect faces from gray-scaled image, using default parameters (scaleFactor) faces = face_detector.detectMultiScale(gray, scaleFactor = 1.1, minNeighbors = 5) # Note: Format of faces will be: [ [top_left_x, top_left_y, w, h (for face 1)], [... (for face 2)], ... ] Once you have ROI (Region Of Interest) of the faces in the image, we can go ahead and start cropping a circle (yay!).\nStep 2: Get circle circumscribing the face From Step-1, we got the faces. Let’s iterate through each face, and get the equation of the circle circumscribing that face. As we discussed before in the Intuition section, we’ll have to calculate the radius and center of the face.\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here Here, we find the circle contained in the rectangle (closest) for each face. Let’s go ahead and crop this circle one by one, and see how we can use this for Portrait Bokeh!\nStep 3: Crop the circle and store it in different array We discussed the pseudo code of this in Cropping a Circle section of this blog. But before this, we have to figure out: How to find a point is within that circle? Think of this as a simple maths problem where you have to find a given coordinate is inside a circle or not. What would you do?\nFind distance between point and center of the circle. If distance is greater than radius, it’s outside. If distance is equal to radius, it’s on the boundary. If distance is less than radius, it’s inside. We can simplify this for circle as we know it’s equation: (point_x - center_x)^2 + (point_y - center_y)^2 - radius^2, which will be:\n0 if the point is on the boundary. greater than 0 if the point is outside the circle. less than 0 if the point is inside the circle. Let’s use this concept here:\ndef is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through all the pixels in the image for row in range(img.shape[0]): for col in range(img.shape[1]): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque img[row][col][3] = 0 else: # Means the point is outside the face # Make it transparent img[row][col][3] = 255 We will have to execute the for loop once for each face, which means the code becomes:\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent, by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(img.shape[0]): for col in range(img.shape[1]): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 If you notice, we have 3 nested for loops, which will result into really non-efficient code for HD Images (1920x1080 images? Think of the number of computations happening in this case). Suppose we have 3 faces detected and our input image is 1920 x 1080 (width x height). Total number of times the function is_inside called will be: 3 x 1920 x 1080, which is 6220800 (approx. 6.2 Million or 62 Lacs). It’s a lot!\nWe can not avoid these loops though, but why iterate through the whole image when you know the circle is anyways gonna be within that rectangle (face)! Imagine the face is 200 x 200 now, and everything remains same (3 faces, HD input Image: 1920 x 1080). If we only iterate through the face everytime, the computations will be: 3 * 200 * 200, which is 120000 (120 thousand or 1.2 lacs). Much better. All we have to do is, pick the face ROI, and iterate through that region. Everything else remains same:\nfor row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 So, the code should look like this:\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside((col, row), center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 Let’s try to visualize imgTransp here and see how this looks like:\nThis looks good so far! We have cropped the circle (face), and all we need to do now is - overlay this image on a blurred image. Let’s head straight to Step 4.\nStep 4: Blurring and overlaying In Step 3, we were able to crop the circle. But think about this, whenever we know the pixel is inside the face, let’s just replace the blurred pixel with original image.\n# Blur the whole image first img_blurred = cv2.GaussianBlur(img, (11, 11), 0) # Iterate through the faces we were doing before # Whenever the pixel is inside, replace the point at img_blurred with original img # Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside((col, row), center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 # Replace pixel of blurred image with original image imgBlurred[row][col] = img[row][col] else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 Note: The only reason we used imgTransp here, is to show how to crop a circle. For portrait bokeh, you don’t need to have imgTransp and transparency channels.\nHere is how the output looks like. While I understand that there is still some background, but we can definitely be better than this - and this will be our topic for the next blog!\nThis should be it for this blog, and I hope you learnt something new today. If you liked the content, please leave a comment below. I would love to read your feedbacks, suggestions and if this helped you out in any way. I also go live on weekends, and upload videos on weekdays on my YouTube Channel, so make sure to subscribe there and join me in if you find it interesting! Thank you for reading this blog.\n",
  "wordCount" : "2125",
  "inLanguage": "en",
  "datePublished": "2020-12-10T00:00:00Z",
  "dateModified": "2020-12-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": {"name":"Kushashwa Ravi Shrimali"}
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kushashwa Ravi Shrimali (Kush)",
    "logo": {
      "@type": "ImageObject",
      "url": "https://krshrimali.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://krshrimali.github.io/" accesskey="h" title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://krshrimali.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://krshrimali.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://krshrimali.github.io/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://krshrimali.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://krshrimali.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2
    </h1>
    <div class="post-meta"><span title='2020-12-10 00:00:00 +0000 UTC'>December 10, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;map[name:Kushashwa Ravi Shrimali]

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intuition-behind-cropping-a-circle" aria-label="Intuition behind cropping a circle">Intuition behind cropping a circle</a></li>
                <li>
                    <a href="#methodology" aria-label="Methodology">Methodology</a></li>
                <li>
                    <a href="#cropping-a-circle" aria-label="Cropping a circle">Cropping a circle</a></li>
                <li>
                    <a href="#video-tutorial" aria-label="Video Tutorial">Video Tutorial</a></li>
                <li>
                    <a href="#step-1-get-face-from-face-detection" aria-label="Step 1: Get face from face detection">Step 1: Get face from face detection</a></li>
                <li>
                    <a href="#step-2-get-circle-circumscribing-the-face" aria-label="Step 2: Get circle circumscribing the face">Step 2: Get circle circumscribing the face</a></li>
                <li>
                    <a href="#step-3-crop-the-circle-and-store-it-in-different-array" aria-label="Step 3: Crop the circle and store it in different array">Step 3: Crop the circle and store it in different array</a></li>
                <li>
                    <a href="#step-4-blurring-and-overlaying" aria-label="Step 4: Blurring and overlaying">Step 4: Blurring and overlaying</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Dec_10_2020.jpg"></p>
<p>Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:</p>
<ul>
<li>The face cropped was a rectangle, and it was clearly visible in the output result.</li>
</ul>
<p>To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition.</p>
<h2 id="intuition-behind-cropping-a-circle">Intuition behind cropping a circle<a hidden class="anchor" aria-hidden="true" href="#intuition-behind-cropping-a-circle">#</a></h2>
<p>while pixels are just the brightness values for each channel at a particular coordinate, so you can&rsquo;t really get half of the pixel and crop an exact circle. But the closest we can get to cropping a circle, is to imagine a circle circumscribed in a rectangle (face detection algorithm in OpenCV - CascadeClassifier returns a rectangle - can be a square as well). So if we are able to get a circle from our output of face detection (a rectangle), we will be closer to what we want.</p>
<p>But how do we get started? Clearly, since the circle is circumscribing the rectangle, the closest we can get to finding radius is: <code>max(width, height)/2</code>. While center will be: <code>(top_left_x + width/2, top_left_y + height/2)</code>. Once we know these two properties of the circle, we will now have the circle equation.</p>
<h2 id="methodology">Methodology<a hidden class="anchor" aria-hidden="true" href="#methodology">#</a></h2>
<p>Let&rsquo;s divide this problem statement into steps:</p>
<ol>
<li>Get face from Face Detection.</li>
<li>Get circle circumscribing the face (rectangle).</li>
<li>Crop the circle and store it in different array.</li>
<li>Blur the whole image except the face.</li>
</ol>
<p>Essentially, the main goal is to get the face cropped as a circle. Once we have that, we can simply overlay this on the blurred image. The trick is to figure out on how we can crop the circle once we know it&rsquo;s coordinates. Let&rsquo;s talk about it&rsquo;s solution in the next section.</p>
<h2 id="cropping-a-circle">Cropping a circle<a hidden class="anchor" aria-hidden="true" href="#cropping-a-circle">#</a></h2>
<p>Usually, our images will have 3 channels (colored image): Blue, Green, Red (BGR). How about we add a transparency channel to our image? The idea behind this is to make all pixels transparent which are NOT in the face, and all the pixels opaque which are within/on the face (circle) boundary. The pseudo code for this should look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Assuming you got a circle equation representing the face</span>
</span></span><span style="display:flex;"><span>face <span style="color:#f92672">=</span> circle_equation
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now iterate through all the pixel values in the imagge</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if the pixel is outside the face, if yes - then make it transparent</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Else - opaque</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> pixel_value <span style="color:#f92672">in</span> image:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> pixel_value <span style="color:#f92672">is</span> outside the face:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make this pixel transparent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make this pixel opaque</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># This will be visible</span>
</span></span></code></pre></div><p>To have an option to add transparency, you need to convert the BGR input image to BGRA (4 channel image: Blue, Green, Red, Alpha) - here Alpha channel denotes transparency channel. When the transparency is set to 0, that represents opaque and when it&rsquo;s set to 255, it represents transparent value. Let&rsquo;s go ahead and use this for our application.</p>
<h2 id="video-tutorial">Video Tutorial<a hidden class="anchor" aria-hidden="true" href="#video-tutorial">#</a></h2>
<p>I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven&rsquo;t seen it before, please check it out <a href="https://youtube.com/c/kushashwaraviShrimali">here</a>. For this blog, I have already uploaded a detailed tutorial. Check it out <a href="https://www.youtube.com/watch?v=7seEhDVGvn4">here</a>.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/7seEhDVGvn4?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<h2 id="step-1-get-face-from-face-detection">Step 1: Get face from face detection<a hidden class="anchor" aria-hidden="true" href="#step-1-get-face-from-face-detection">#</a></h2>
<p>We have discussed this <a href="https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/">before</a>, so we won&rsquo;t go in details but for the sake of continuity, I&rsquo;ll add the code for Face Detection.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> cv2<span style="color:#f92672">,</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get image path and read image</span>
</span></span><span style="display:flex;"><span>img_path <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;sample.png&#34;</span>
</span></span><span style="display:flex;"><span>img <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>imread(img_path, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Convert to grayscale, since Face Detection takes gray scale image as input</span>
</span></span><span style="display:flex;"><span>gray <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(img, cv2<span style="color:#f92672">.</span>COLOR_BGR2GRAY)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initialize face detector from the model file</span>
</span></span><span style="display:flex;"><span>face_detector <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>CascadeClassifier(<span style="color:#e6db74">&#34;haarcascade_frontalface_default.xml&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Detect faces from gray-scaled image, using default parameters (scaleFactor)</span>
</span></span><span style="display:flex;"><span>faces <span style="color:#f92672">=</span> face_detector<span style="color:#f92672">.</span>detectMultiScale(gray, scaleFactor <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>, minNeighbors <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Note: Format of faces will be: [ [top_left_x, top_left_y, w, h (for face 1)], [... (for face 2)], ... ]</span>
</span></span></code></pre></div><p>Once you have ROI (Region Of Interest) of the faces in the image, we can go ahead and start cropping a circle (yay!).</p>
<h2 id="step-2-get-circle-circumscribing-the-face">Step 2: Get circle circumscribing the face<a hidden class="anchor" aria-hidden="true" href="#step-2-get-circle-circumscribing-the-face">#</a></h2>
<p>From Step-1, we got the faces. Let&rsquo;s iterate through each face, and get the equation of the circle circumscribing that face. As we discussed before in the <strong>Intuition</strong> section, we&rsquo;ll have to calculate the radius and center of the face.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Make sure to convert BGR to BGRA image first</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To be used later</span>
</span></span><span style="display:flex;"><span>imgTransp <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(img, cv2<span style="color:#f92672">.</span>COLOR_BGR2BGRA)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through each face one by one</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> face <span style="color:#f92672">in</span> faces:
</span></span><span style="display:flex;"><span>    top_left_x, top_left_y, width, height <span style="color:#f92672">=</span> face[<span style="color:#ae81ff">0</span>], face[<span style="color:#ae81ff">1</span>], face[<span style="color:#ae81ff">2</span>], face[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    radius <span style="color:#f92672">=</span> max(width, height)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    center <span style="color:#f92672">=</span> (top_left_x <span style="color:#f92672">+</span> width<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, top_left_y <span style="color:#f92672">+</span> height<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Cropping circle code will come here</span>
</span></span></code></pre></div><p>Here, we find the circle contained in the rectangle (closest) for each face. Let&rsquo;s go ahead and crop this circle one by one, and see how we can use this for Portrait Bokeh!</p>
<h2 id="step-3-crop-the-circle-and-store-it-in-different-array">Step 3: Crop the circle and store it in different array<a hidden class="anchor" aria-hidden="true" href="#step-3-crop-the-circle-and-store-it-in-different-array">#</a></h2>
<p>We discussed the pseudo code of this in <strong>Cropping a Circle</strong> section of this blog. But before this, we have to figure out: How to find a point is within that circle? Think of this as a simple maths problem where you have to find a given coordinate is inside a circle or not. What would you do?</p>
<ul>
<li>Find distance between point and center of the circle.</li>
<li>If distance is greater than radius, it&rsquo;s outside.</li>
<li>If distance is equal to radius, it&rsquo;s on the boundary.</li>
<li>If distance is less than radius, it&rsquo;s inside.</li>
</ul>
<p>We can simplify this for circle as we know it&rsquo;s equation: <code>(point_x - center_x)^2 + (point_y - center_y)^2 - radius^2</code>, which will be:</p>
<ul>
<li>0 if the point is on the boundary.</li>
<li>greater than 0 if the point is outside the circle.</li>
<li>less than 0 if the point is inside the circle.</li>
</ul>
<p>Let&rsquo;s use this concept here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_inside</span>(point, center, radius):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    eqn <span style="color:#f92672">=</span> (point[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (point[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">1</span>])<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> radius<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> eqn <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through all the pixels in the image</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(img<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(img<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_inside(img[row][col], center, radius):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Means the point is inside/on the face</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Make it opaque</span>
</span></span><span style="display:flex;"><span>            img[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Means the point is outside the face</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Make it transparent</span>
</span></span><span style="display:flex;"><span>            img[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span></code></pre></div><p>We will have to execute the for loop once for each face, which means the code becomes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Make sure to convert BGR to BGRA image first</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To be used later</span>
</span></span><span style="display:flex;"><span>imgTransp <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(img, cv2<span style="color:#f92672">.</span>COLOR_BGR2BGRA)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make the whole image transparent, by default</span>
</span></span><span style="display:flex;"><span>imgTransp[<span style="color:#f92672">...</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_inside</span>(point, center, radius):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    eqn <span style="color:#f92672">=</span> (point[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (point[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">1</span>])<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> radius<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> eqn <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through each face one by one</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> face <span style="color:#f92672">in</span> faces:
</span></span><span style="display:flex;"><span>    top_left_x, top_left_y, width, height <span style="color:#f92672">=</span> face[<span style="color:#ae81ff">0</span>], face[<span style="color:#ae81ff">1</span>], face[<span style="color:#ae81ff">2</span>], face[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    radius <span style="color:#f92672">=</span> max(width, height)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    center <span style="color:#f92672">=</span> (top_left_x <span style="color:#f92672">+</span> width<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, top_left_y <span style="color:#f92672">+</span> height<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Cropping circle code will come here</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Iterate through all the pixels in the image</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(img<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(img<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> is_inside(img[row][col], center, radius):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is inside/on the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it opaque</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is outside the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it transparent</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>If you notice, we have 3 nested for loops, which will result into really non-efficient code for HD Images (1920x1080 images? Think of the number of computations happening in this case). Suppose we have 3 faces detected and our input image is 1920 x 1080 (width x height). Total number of times the function <code>is_inside</code> called will be: 3 x 1920 x 1080, which is 6220800 (approx. 6.2 Million or 62 Lacs). It&rsquo;s a lot!</p>
<p>We can not avoid these loops though, but why iterate through the whole image when you know the circle is anyways gonna be within that rectangle (face)! Imagine the face is 200 x 200 now, and everything remains same (3 faces, HD input Image: 1920 x 1080). If we only iterate through the face everytime, the computations will be: 3 * 200 * 200, which is 120000 (120 thousand or 1.2 lacs). Much better. All we have to do is, pick the face ROI, and iterate through that region. Everything else remains same:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(tly, tly <span style="color:#f92672">+</span> height):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(tlx, tlx <span style="color:#f92672">+</span> width):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_inside(img[row][col], center, radius):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Means the point is inside/on the face</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Make it opaque</span>
</span></span><span style="display:flex;"><span>            imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Means the point is outside the face</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Make it transparent</span>
</span></span><span style="display:flex;"><span>            imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>So, the code should look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Make sure to convert BGR to BGRA image first</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To be used later</span>
</span></span><span style="display:flex;"><span>imgTransp <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(img, cv2<span style="color:#f92672">.</span>COLOR_BGR2BGRA)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make the whole image transparent by default</span>
</span></span><span style="display:flex;"><span>imgTransp[<span style="color:#f92672">...</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_inside</span>(point, center, radius):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    eqn <span style="color:#f92672">=</span> (point[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (point[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">1</span>])<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> radius<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> eqn <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through each face one by one</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> face <span style="color:#f92672">in</span> faces:
</span></span><span style="display:flex;"><span>    top_left_x, top_left_y, width, height <span style="color:#f92672">=</span> face[<span style="color:#ae81ff">0</span>], face[<span style="color:#ae81ff">1</span>], face[<span style="color:#ae81ff">2</span>], face[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    radius <span style="color:#f92672">=</span> max(width, height)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    center <span style="color:#f92672">=</span> (top_left_x <span style="color:#f92672">+</span> width<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, top_left_y <span style="color:#f92672">+</span> height<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Cropping circle code will come here</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Iterate through all the pixels in the image</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(tly, tly <span style="color:#f92672">+</span> height):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(tlx, tlx <span style="color:#f92672">+</span> width):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> is_inside((col, row), center, radius):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is inside/on the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it opaque</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is outside the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it transparent</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>Let&rsquo;s try to visualize <code>imgTransp</code> here and see how this looks like:</p>
<img src="https://krshrimali.github.io/assets/opencv/imgTransp_output.png"/>
<p>This looks good so far! We have cropped the circle (face), and all we need to do now is - overlay this image on a blurred image. Let&rsquo;s head straight to Step 4.</p>
<h2 id="step-4-blurring-and-overlaying">Step 4: Blurring and overlaying<a hidden class="anchor" aria-hidden="true" href="#step-4-blurring-and-overlaying">#</a></h2>
<p>In Step 3, we were able to crop the circle. But think about this, whenever we know the pixel is inside the face, let&rsquo;s just replace the blurred pixel with original image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Blur the whole image first</span>
</span></span><span style="display:flex;"><span>img_blurred <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>GaussianBlur(img, (<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">11</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through the faces we were doing before</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Whenever the pixel is inside, replace the point at img_blurred with original img</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make sure to convert BGR to BGRA image first</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To be used later</span>
</span></span><span style="display:flex;"><span>imgTransp <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(img, cv2<span style="color:#f92672">.</span>COLOR_BGR2BGRA)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make the whole image transparent by default</span>
</span></span><span style="display:flex;"><span>imgTransp[<span style="color:#f92672">...</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_inside</span>(point, center, radius):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    eqn <span style="color:#f92672">=</span> (point[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (point[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> center[<span style="color:#ae81ff">1</span>])<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> radius<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> eqn <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterate through each face one by one</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> face <span style="color:#f92672">in</span> faces:
</span></span><span style="display:flex;"><span>    top_left_x, top_left_y, width, height <span style="color:#f92672">=</span> face[<span style="color:#ae81ff">0</span>], face[<span style="color:#ae81ff">1</span>], face[<span style="color:#ae81ff">2</span>], face[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    radius <span style="color:#f92672">=</span> max(width, height)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    center <span style="color:#f92672">=</span> (top_left_x <span style="color:#f92672">+</span> width<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, top_left_y <span style="color:#f92672">+</span> height<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Cropping circle code will come here</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Iterate through all the pixels in the image</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(tly, tly <span style="color:#f92672">+</span> height):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> col <span style="color:#f92672">in</span> range(tlx, tlx <span style="color:#f92672">+</span> width):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> is_inside((col, row), center, radius):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is inside/on the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it opaque</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Replace pixel of blurred image with original image</span>
</span></span><span style="display:flex;"><span>                imgBlurred[row][col] <span style="color:#f92672">=</span> img[row][col]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Means the point is outside the face</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Make it transparent</span>
</span></span><span style="display:flex;"><span>                imgTransp[row][col][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p><strong>Note:</strong> The only reason we used <code>imgTransp</code> here, is to show how to crop a circle. For portrait bokeh, you don&rsquo;t need to have <code>imgTransp</code> and transparency channels.</p>
<p>Here is how the output looks like. While I understand that there is still some background, but we can definitely be better than this - and this will be our topic for the next blog!</p>
<img src="https://krshrimali.github.io/assets/opencv/imgPortraitBokehCroppingCircle.png"/>
<p>This should be it for this blog, and I hope you learnt something new today. If you liked the content, please leave a comment below. I would love to read your feedbacks, suggestions and if this helped you out in any way. I also go live on weekends, and upload videos on weekdays on my <a href="https://youtube.com/c/kushashwaraviShrimali">YouTube Channel</a>, so make sure to subscribe there and join me in if you find it interesting! Thank you for reading this blog.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://krshrimali.github.io/tags/computer-vision/">Computer Vision</a></li>
      <li><a href="https://krshrimali.github.io/tags/python/">Python</a></li>
      <li><a href="https://krshrimali.github.io/tags/portrait-bokeh/">Portrait Bokeh</a></li>
      <li><a href="https://krshrimali.github.io/tags/image-processing/">Image Processing</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://krshrimali.github.io/posts/2021/07/function-pointers-and-function-objects-in-c-/">
    <span class="title">« Prev</span>
    <br>
    <span>Function Pointers and Function Objects in C&#43;&#43;</span>
  </a>
  <a class="next" href="https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/">
    <span class="title">Next »</span>
    <br>
    <span>Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on x"
            href="https://x.com/intent/tweet/?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&amp;hashtags=computervision%2cpython%2cportraitbokeh%2cimageprocessing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&amp;title=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;summary=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&title=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on whatsapp"
            href="https://api.whatsapp.com/send?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on telegram"
            href="https://telegram.me/share/url?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
