<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 | Kushashwa Ravi Shrimali (Kush)</title><meta name=keywords content="computer vision,python,portrait bokeh,image processing"><meta name=description content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:

The face cropped was a rectangle, and it was clearly visible in the output result.

To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition."><meta name=author content="map[name:Kushashwa Ravi Shrimali]"><link rel=canonical href=https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/><link crossorigin=anonymous href=https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://krshrimali.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://krshrimali.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://krshrimali.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://krshrimali.github.io/apple-touch-icon.png><link rel=mask-icon href=https://krshrimali.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/"><meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)"><meta property="og:title" content="How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2"><meta property="og:description" content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:
The face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of “some” of the background noise we got earlier, for Portrait Bokeh. Let’s take this step by step, and first talk about the intuition."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-10T00:00:00+00:00"><meta property="article:tag" content="Computer Vision"><meta property="article:tag" content="Python"><meta property="article:tag" content="Portrait Bokeh"><meta property="article:tag" content="Image Processing"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2"><meta name=twitter:description content="
Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:

The face cropped was a rectangle, and it was clearly visible in the output result.

To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://krshrimali.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2","item":"https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2","name":"How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2","description":"\nHi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:\nThe face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of \u0026ldquo;some\u0026rdquo; of the background noise we got earlier, for Portrait Bokeh. Let\u0026rsquo;s take this step by step, and first talk about the intuition.\n","keywords":["computer vision","python","portrait bokeh","image processing"],"articleBody":"\nHi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:\nThe face cropped was a rectangle, and it was clearly visible in the output result. To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of “some” of the background noise we got earlier, for Portrait Bokeh. Let’s take this step by step, and first talk about the intuition.\nIntuition behind cropping a circle while pixels are just the brightness values for each channel at a particular coordinate, so you can’t really get half of the pixel and crop an exact circle. But the closest we can get to cropping a circle, is to imagine a circle circumscribed in a rectangle (face detection algorithm in OpenCV - CascadeClassifier returns a rectangle - can be a square as well). So if we are able to get a circle from our output of face detection (a rectangle), we will be closer to what we want.\nBut how do we get started? Clearly, since the circle is circumscribing the rectangle, the closest we can get to finding radius is: max(width, height)/2. While center will be: (top_left_x + width/2, top_left_y + height/2). Once we know these two properties of the circle, we will now have the circle equation.\nMethodology Let’s divide this problem statement into steps:\nGet face from Face Detection. Get circle circumscribing the face (rectangle). Crop the circle and store it in different array. Blur the whole image except the face. Essentially, the main goal is to get the face cropped as a circle. Once we have that, we can simply overlay this on the blurred image. The trick is to figure out on how we can crop the circle once we know it’s coordinates. Let’s talk about it’s solution in the next section.\nCropping a circle Usually, our images will have 3 channels (colored image): Blue, Green, Red (BGR). How about we add a transparency channel to our image? The idea behind this is to make all pixels transparent which are NOT in the face, and all the pixels opaque which are within/on the face (circle) boundary. The pseudo code for this should look something like this:\n# Assuming you got a circle equation representing the face face = circle_equation # Now iterate through all the pixel values in the imagge # Check if the pixel is outside the face, if yes - then make it transparent # Else - opaque for pixel_value in image: if pixel_value is outside the face: # Make this pixel transparent else: # Make this pixel opaque # This will be visible To have an option to add transparency, you need to convert the BGR input image to BGRA (4 channel image: Blue, Green, Red, Alpha) - here Alpha channel denotes transparency channel. When the transparency is set to 0, that represents opaque and when it’s set to 255, it represents transparent value. Let’s go ahead and use this for our application.\nVideo Tutorial I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven’t seen it before, please check it out here. For this blog, I have already uploaded a detailed tutorial. Check it out here.\nStep 1: Get face from face detection We have discussed this before, so we won’t go in details but for the sake of continuity, I’ll add the code for Face Detection.\nimport cv2, sys # Get image path and read image img_path = sys.argv[1] if len(sys.argv) \u003e 1 else \"sample.png\" img = cv2.imread(img_path, 1) # Convert to grayscale, since Face Detection takes gray scale image as input gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Initialize face detector from the model file face_detector = cv2.CascadeClassifier(\"haarcascade_frontalface_default.xml\") # Detect faces from gray-scaled image, using default parameters (scaleFactor) faces = face_detector.detectMultiScale(gray, scaleFactor = 1.1, minNeighbors = 5) # Note: Format of faces will be: [ [top_left_x, top_left_y, w, h (for face 1)], [... (for face 2)], ... ] Once you have ROI (Region Of Interest) of the faces in the image, we can go ahead and start cropping a circle (yay!).\nStep 2: Get circle circumscribing the face From Step-1, we got the faces. Let’s iterate through each face, and get the equation of the circle circumscribing that face. As we discussed before in the Intuition section, we’ll have to calculate the radius and center of the face.\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here Here, we find the circle contained in the rectangle (closest) for each face. Let’s go ahead and crop this circle one by one, and see how we can use this for Portrait Bokeh!\nStep 3: Crop the circle and store it in different array We discussed the pseudo code of this in Cropping a Circle section of this blog. But before this, we have to figure out: How to find a point is within that circle? Think of this as a simple maths problem where you have to find a given coordinate is inside a circle or not. What would you do?\nFind distance between point and center of the circle. If distance is greater than radius, it’s outside. If distance is equal to radius, it’s on the boundary. If distance is less than radius, it’s inside. We can simplify this for circle as we know it’s equation: (point_x - center_x)^2 + (point_y - center_y)^2 - radius^2, which will be:\n0 if the point is on the boundary. greater than 0 if the point is outside the circle. less than 0 if the point is inside the circle. Let’s use this concept here:\ndef is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through all the pixels in the image for row in range(img.shape[0]): for col in range(img.shape[1]): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque img[row][col][3] = 0 else: # Means the point is outside the face # Make it transparent img[row][col][3] = 255 We will have to execute the for loop once for each face, which means the code becomes:\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent, by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(img.shape[0]): for col in range(img.shape[1]): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 If you notice, we have 3 nested for loops, which will result into really non-efficient code for HD Images (1920x1080 images? Think of the number of computations happening in this case). Suppose we have 3 faces detected and our input image is 1920 x 1080 (width x height). Total number of times the function is_inside called will be: 3 x 1920 x 1080, which is 6220800 (approx. 6.2 Million or 62 Lacs). It’s a lot!\nWe can not avoid these loops though, but why iterate through the whole image when you know the circle is anyways gonna be within that rectangle (face)! Imagine the face is 200 x 200 now, and everything remains same (3 faces, HD input Image: 1920 x 1080). If we only iterate through the face everytime, the computations will be: 3 * 200 * 200, which is 120000 (120 thousand or 1.2 lacs). Much better. All we have to do is, pick the face ROI, and iterate through that region. Everything else remains same:\nfor row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside(img[row][col], center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 So, the code should look like this:\n# Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside((col, row), center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 Let’s try to visualize imgTransp here and see how this looks like:\nThis looks good so far! We have cropped the circle (face), and all we need to do now is - overlay this image on a blurred image. Let’s head straight to Step 4.\nStep 4: Blurring and overlaying In Step 3, we were able to crop the circle. But think about this, whenever we know the pixel is inside the face, let’s just replace the blurred pixel with original image.\n# Blur the whole image first img_blurred = cv2.GaussianBlur(img, (11, 11), 0) # Iterate through the faces we were doing before # Whenever the pixel is inside, replace the point at img_blurred with original img # Make sure to convert BGR to BGRA image first # To be used later imgTransp = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # Make the whole image transparent by default imgTransp[..., 3] = 255 def is_inside(point, center, radius): \"\"\" This function returns True if point is inside/on the boundary, False otherwise \"\"\" eqn = (point[0] - center[0]) ** 2 + (point[1] - center[1])**2 - radius**2 return eqn \u003c= 0 # Iterate through each face one by one for face in faces: top_left_x, top_left_y, width, height = face[0], face[1], face[2], face[3] radius = max(width, height)/2 center = (top_left_x + width/2, top_left_y + height/2) # Cropping circle code will come here # Iterate through all the pixels in the image for row in range(tly, tly + height): for col in range(tlx, tlx + width): if is_inside((col, row), center, radius): # Means the point is inside/on the face # Make it opaque imgTransp[row][col][3] = 255 # Replace pixel of blurred image with original image imgBlurred[row][col] = img[row][col] else: # Means the point is outside the face # Make it transparent imgTransp[row][col][3] = 0 Note: The only reason we used imgTransp here, is to show how to crop a circle. For portrait bokeh, you don’t need to have imgTransp and transparency channels.\nHere is how the output looks like. While I understand that there is still some background, but we can definitely be better than this - and this will be our topic for the next blog!\nThis should be it for this blog, and I hope you learnt something new today. If you liked the content, please leave a comment below. I would love to read your feedbacks, suggestions and if this helped you out in any way. I also go live on weekends, and upload videos on weekdays on my YouTube Channel, so make sure to subscribe there and join me in if you find it interesting! Thank you for reading this blog.\n","wordCount":"2125","inLanguage":"en","datePublished":"2020-12-10T00:00:00Z","dateModified":"2020-12-10T00:00:00Z","author":{"@type":"Person","name":{"name":"Kushashwa Ravi Shrimali"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/"},"publisher":{"@type":"Organization","name":"Kushashwa Ravi Shrimali (Kush)","logo":{"@type":"ImageObject","url":"https://krshrimali.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://krshrimali.github.io/ accesskey=h title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://krshrimali.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://krshrimali.github.io/about title=About><span>About</span></a></li><li><a href=https://krshrimali.github.io/posts title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://krshrimali.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://krshrimali.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2</h1><div class=post-meta><span title='2020-12-10 00:00:00 +0000 UTC'>December 10, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;map[name:Kushashwa Ravi Shrimali]</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intuition-behind-cropping-a-circle aria-label="Intuition behind cropping a circle">Intuition behind cropping a circle</a></li><li><a href=#methodology aria-label=Methodology>Methodology</a></li><li><a href=#cropping-a-circle aria-label="Cropping a circle">Cropping a circle</a></li><li><a href=#video-tutorial aria-label="Video Tutorial">Video Tutorial</a></li><li><a href=#step-1-get-face-from-face-detection aria-label="Step 1: Get face from face detection">Step 1: Get face from face detection</a></li><li><a href=#step-2-get-circle-circumscribing-the-face aria-label="Step 2: Get circle circumscribing the face">Step 2: Get circle circumscribing the face</a></li><li><a href=#step-3-crop-the-circle-and-store-it-in-different-array aria-label="Step 3: Crop the circle and store it in different array">Step 3: Crop the circle and store it in different array</a></li><li><a href=#step-4-blurring-and-overlaying aria-label="Step 4: Blurring and overlaying">Step 4: Blurring and overlaying</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Dec_10_2020.jpg></p><p>Hi everyone! In the previous blog we implemented Portrait Bokeh using Face Detection in OpenCV. While the results were good for a start, we definitely want to be closer to the output we expect. The end goal is to blur everything except the face. The main problem we noticed was:</p><ul><li>The face cropped was a rectangle, and it was clearly visible in the output result.</li></ul><p>To overcome this, we will be talking about cropping a circle in OpenCV today. This will enable us to get rid of &ldquo;some&rdquo; of the background noise we got earlier, for Portrait Bokeh. Let&rsquo;s take this step by step, and first talk about the intuition.</p><h2 id=intuition-behind-cropping-a-circle>Intuition behind cropping a circle<a hidden class=anchor aria-hidden=true href=#intuition-behind-cropping-a-circle>#</a></h2><p>while pixels are just the brightness values for each channel at a particular coordinate, so you can&rsquo;t really get half of the pixel and crop an exact circle. But the closest we can get to cropping a circle, is to imagine a circle circumscribed in a rectangle (face detection algorithm in OpenCV - CascadeClassifier returns a rectangle - can be a square as well). So if we are able to get a circle from our output of face detection (a rectangle), we will be closer to what we want.</p><p>But how do we get started? Clearly, since the circle is circumscribing the rectangle, the closest we can get to finding radius is: <code>max(width, height)/2</code>. While center will be: <code>(top_left_x + width/2, top_left_y + height/2)</code>. Once we know these two properties of the circle, we will now have the circle equation.</p><h2 id=methodology>Methodology<a hidden class=anchor aria-hidden=true href=#methodology>#</a></h2><p>Let&rsquo;s divide this problem statement into steps:</p><ol><li>Get face from Face Detection.</li><li>Get circle circumscribing the face (rectangle).</li><li>Crop the circle and store it in different array.</li><li>Blur the whole image except the face.</li></ol><p>Essentially, the main goal is to get the face cropped as a circle. Once we have that, we can simply overlay this on the blurred image. The trick is to figure out on how we can crop the circle once we know it&rsquo;s coordinates. Let&rsquo;s talk about it&rsquo;s solution in the next section.</p><h2 id=cropping-a-circle>Cropping a circle<a hidden class=anchor aria-hidden=true href=#cropping-a-circle>#</a></h2><p>Usually, our images will have 3 channels (colored image): Blue, Green, Red (BGR). How about we add a transparency channel to our image? The idea behind this is to make all pixels transparent which are NOT in the face, and all the pixels opaque which are within/on the face (circle) boundary. The pseudo code for this should look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Assuming you got a circle equation representing the face</span>
</span></span><span style=display:flex><span>face <span style=color:#f92672>=</span> circle_equation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Now iterate through all the pixel values in the imagge</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Check if the pixel is outside the face, if yes - then make it transparent</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Else - opaque</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> pixel_value <span style=color:#f92672>in</span> image:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pixel_value <span style=color:#f92672>is</span> outside the face:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Make this pixel transparent</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Make this pixel opaque</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># This will be visible</span>
</span></span></code></pre></div><p>To have an option to add transparency, you need to convert the BGR input image to BGRA (4 channel image: Blue, Green, Red, Alpha) - here Alpha channel denotes transparency channel. When the transparency is set to 0, that represents opaque and when it&rsquo;s set to 255, it represents transparent value. Let&rsquo;s go ahead and use this for our application.</p><h2 id=video-tutorial>Video Tutorial<a hidden class=anchor aria-hidden=true href=#video-tutorial>#</a></h2><p>I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven&rsquo;t seen it before, please check it out <a href=https://youtube.com/c/kushashwaraviShrimali>here</a>. For this blog, I have already uploaded a detailed tutorial. Check it out <a href="https://www.youtube.com/watch?v=7seEhDVGvn4">here</a>.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/7seEhDVGvn4?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h2 id=step-1-get-face-from-face-detection>Step 1: Get face from face detection<a hidden class=anchor aria-hidden=true href=#step-1-get-face-from-face-detection>#</a></h2><p>We have discussed this <a href=https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/>before</a>, so we won&rsquo;t go in details but for the sake of continuity, I&rsquo;ll add the code for Face Detection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> cv2<span style=color:#f92672>,</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Get image path and read image</span>
</span></span><span style=display:flex><span>img_path <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;sample.png&#34;</span>
</span></span><span style=display:flex><span>img <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(img_path, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Convert to grayscale, since Face Detection takes gray scale image as input</span>
</span></span><span style=display:flex><span>gray <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2GRAY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Initialize face detector from the model file</span>
</span></span><span style=display:flex><span>face_detector <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>CascadeClassifier(<span style=color:#e6db74>&#34;haarcascade_frontalface_default.xml&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Detect faces from gray-scaled image, using default parameters (scaleFactor)</span>
</span></span><span style=display:flex><span>faces <span style=color:#f92672>=</span> face_detector<span style=color:#f92672>.</span>detectMultiScale(gray, scaleFactor <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.1</span>, minNeighbors <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Note: Format of faces will be: [ [top_left_x, top_left_y, w, h (for face 1)], [... (for face 2)], ... ]</span>
</span></span></code></pre></div><p>Once you have ROI (Region Of Interest) of the faces in the image, we can go ahead and start cropping a circle (yay!).</p><h2 id=step-2-get-circle-circumscribing-the-face>Step 2: Get circle circumscribing the face<a hidden class=anchor aria-hidden=true href=#step-2-get-circle-circumscribing-the-face>#</a></h2><p>From Step-1, we got the faces. Let&rsquo;s iterate through each face, and get the equation of the circle circumscribing that face. As we discussed before in the <strong>Intuition</strong> section, we&rsquo;ll have to calculate the radius and center of the face.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Make sure to convert BGR to BGRA image first</span>
</span></span><span style=display:flex><span><span style=color:#75715e># To be used later</span>
</span></span><span style=display:flex><span>imgTransp <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2BGRA)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through each face one by one</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> face <span style=color:#f92672>in</span> faces:
</span></span><span style=display:flex><span>    top_left_x, top_left_y, width, height <span style=color:#f92672>=</span> face[<span style=color:#ae81ff>0</span>], face[<span style=color:#ae81ff>1</span>], face[<span style=color:#ae81ff>2</span>], face[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    radius <span style=color:#f92672>=</span> max(width, height)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> (top_left_x <span style=color:#f92672>+</span> width<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, top_left_y <span style=color:#f92672>+</span> height<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Cropping circle code will come here</span>
</span></span></code></pre></div><p>Here, we find the circle contained in the rectangle (closest) for each face. Let&rsquo;s go ahead and crop this circle one by one, and see how we can use this for Portrait Bokeh!</p><h2 id=step-3-crop-the-circle-and-store-it-in-different-array>Step 3: Crop the circle and store it in different array<a hidden class=anchor aria-hidden=true href=#step-3-crop-the-circle-and-store-it-in-different-array>#</a></h2><p>We discussed the pseudo code of this in <strong>Cropping a Circle</strong> section of this blog. But before this, we have to figure out: How to find a point is within that circle? Think of this as a simple maths problem where you have to find a given coordinate is inside a circle or not. What would you do?</p><ul><li>Find distance between point and center of the circle.</li><li>If distance is greater than radius, it&rsquo;s outside.</li><li>If distance is equal to radius, it&rsquo;s on the boundary.</li><li>If distance is less than radius, it&rsquo;s inside.</li></ul><p>We can simplify this for circle as we know it&rsquo;s equation: <code>(point_x - center_x)^2 + (point_y - center_y)^2 - radius^2</code>, which will be:</p><ul><li>0 if the point is on the boundary.</li><li>greater than 0 if the point is outside the circle.</li><li>less than 0 if the point is inside the circle.</li></ul><p>Let&rsquo;s use this concept here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_inside</span>(point, center, radius):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    eqn <span style=color:#f92672>=</span> (point[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (point[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> radius<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> eqn <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through all the pixels in the image</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> range(img<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>]):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(img<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_inside(img[row][col], center, radius):
</span></span><span style=display:flex><span>            <span style=color:#75715e># Means the point is inside/on the face</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Make it opaque</span>
</span></span><span style=display:flex><span>            img[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Means the point is outside the face</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Make it transparent</span>
</span></span><span style=display:flex><span>            img[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span></code></pre></div><p>We will have to execute the for loop once for each face, which means the code becomes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Make sure to convert BGR to BGRA image first</span>
</span></span><span style=display:flex><span><span style=color:#75715e># To be used later</span>
</span></span><span style=display:flex><span>imgTransp <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2BGRA)
</span></span><span style=display:flex><span><span style=color:#75715e># Make the whole image transparent, by default</span>
</span></span><span style=display:flex><span>imgTransp[<span style=color:#f92672>...</span>, <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_inside</span>(point, center, radius):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    eqn <span style=color:#f92672>=</span> (point[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (point[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> radius<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> eqn <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through each face one by one</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> face <span style=color:#f92672>in</span> faces:
</span></span><span style=display:flex><span>    top_left_x, top_left_y, width, height <span style=color:#f92672>=</span> face[<span style=color:#ae81ff>0</span>], face[<span style=color:#ae81ff>1</span>], face[<span style=color:#ae81ff>2</span>], face[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    radius <span style=color:#f92672>=</span> max(width, height)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> (top_left_x <span style=color:#f92672>+</span> width<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, top_left_y <span style=color:#f92672>+</span> height<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Cropping circle code will come here</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Iterate through all the pixels in the image</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> range(img<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(img<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>]):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> is_inside(img[row][col], center, radius):
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is inside/on the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it opaque</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is outside the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it transparent</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>If you notice, we have 3 nested for loops, which will result into really non-efficient code for HD Images (1920x1080 images? Think of the number of computations happening in this case). Suppose we have 3 faces detected and our input image is 1920 x 1080 (width x height). Total number of times the function <code>is_inside</code> called will be: 3 x 1920 x 1080, which is 6220800 (approx. 6.2 Million or 62 Lacs). It&rsquo;s a lot!</p><p>We can not avoid these loops though, but why iterate through the whole image when you know the circle is anyways gonna be within that rectangle (face)! Imagine the face is 200 x 200 now, and everything remains same (3 faces, HD input Image: 1920 x 1080). If we only iterate through the face everytime, the computations will be: 3 * 200 * 200, which is 120000 (120 thousand or 1.2 lacs). Much better. All we have to do is, pick the face ROI, and iterate through that region. Everything else remains same:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> range(tly, tly <span style=color:#f92672>+</span> height):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(tlx, tlx <span style=color:#f92672>+</span> width):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_inside(img[row][col], center, radius):
</span></span><span style=display:flex><span>            <span style=color:#75715e># Means the point is inside/on the face</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Make it opaque</span>
</span></span><span style=display:flex><span>            imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Means the point is outside the face</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Make it transparent</span>
</span></span><span style=display:flex><span>            imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>So, the code should look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Make sure to convert BGR to BGRA image first</span>
</span></span><span style=display:flex><span><span style=color:#75715e># To be used later</span>
</span></span><span style=display:flex><span>imgTransp <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2BGRA)
</span></span><span style=display:flex><span><span style=color:#75715e># Make the whole image transparent by default</span>
</span></span><span style=display:flex><span>imgTransp[<span style=color:#f92672>...</span>, <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_inside</span>(point, center, radius):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    eqn <span style=color:#f92672>=</span> (point[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (point[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> radius<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> eqn <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through each face one by one</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> face <span style=color:#f92672>in</span> faces:
</span></span><span style=display:flex><span>    top_left_x, top_left_y, width, height <span style=color:#f92672>=</span> face[<span style=color:#ae81ff>0</span>], face[<span style=color:#ae81ff>1</span>], face[<span style=color:#ae81ff>2</span>], face[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    radius <span style=color:#f92672>=</span> max(width, height)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> (top_left_x <span style=color:#f92672>+</span> width<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, top_left_y <span style=color:#f92672>+</span> height<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Cropping circle code will come here</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Iterate through all the pixels in the image</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> range(tly, tly <span style=color:#f92672>+</span> height):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(tlx, tlx <span style=color:#f92672>+</span> width):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> is_inside((col, row), center, radius):
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is inside/on the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it opaque</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is outside the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it transparent</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Let&rsquo;s try to visualize <code>imgTransp</code> here and see how this looks like:</p><img src=https://krshrimali.github.io/assets/opencv/imgTransp_output.png><p>This looks good so far! We have cropped the circle (face), and all we need to do now is - overlay this image on a blurred image. Let&rsquo;s head straight to Step 4.</p><h2 id=step-4-blurring-and-overlaying>Step 4: Blurring and overlaying<a hidden class=anchor aria-hidden=true href=#step-4-blurring-and-overlaying>#</a></h2><p>In Step 3, we were able to crop the circle. But think about this, whenever we know the pixel is inside the face, let&rsquo;s just replace the blurred pixel with original image.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Blur the whole image first</span>
</span></span><span style=display:flex><span>img_blurred <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>GaussianBlur(img, (<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>11</span>), <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through the faces we were doing before</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Whenever the pixel is inside, replace the point at img_blurred with original img</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Make sure to convert BGR to BGRA image first</span>
</span></span><span style=display:flex><span><span style=color:#75715e># To be used later</span>
</span></span><span style=display:flex><span>imgTransp <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2BGRA)
</span></span><span style=display:flex><span><span style=color:#75715e># Make the whole image transparent by default</span>
</span></span><span style=display:flex><span>imgTransp[<span style=color:#f92672>...</span>, <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_inside</span>(point, center, radius):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34; This function returns True if point is inside/on the boundary, False otherwise &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    eqn <span style=color:#f92672>=</span> (point[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (point[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> center[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> radius<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> eqn <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Iterate through each face one by one</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> face <span style=color:#f92672>in</span> faces:
</span></span><span style=display:flex><span>    top_left_x, top_left_y, width, height <span style=color:#f92672>=</span> face[<span style=color:#ae81ff>0</span>], face[<span style=color:#ae81ff>1</span>], face[<span style=color:#ae81ff>2</span>], face[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    radius <span style=color:#f92672>=</span> max(width, height)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> (top_left_x <span style=color:#f92672>+</span> width<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, top_left_y <span style=color:#f92672>+</span> height<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Cropping circle code will come here</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Iterate through all the pixels in the image</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> range(tly, tly <span style=color:#f92672>+</span> height):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> range(tlx, tlx <span style=color:#f92672>+</span> width):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> is_inside((col, row), center, radius):
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is inside/on the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it opaque</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Replace pixel of blurred image with original image</span>
</span></span><span style=display:flex><span>                imgBlurred[row][col] <span style=color:#f92672>=</span> img[row][col]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Means the point is outside the face</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make it transparent</span>
</span></span><span style=display:flex><span>                imgTransp[row][col][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p><strong>Note:</strong> The only reason we used <code>imgTransp</code> here, is to show how to crop a circle. For portrait bokeh, you don&rsquo;t need to have <code>imgTransp</code> and transparency channels.</p><p>Here is how the output looks like. While I understand that there is still some background, but we can definitely be better than this - and this will be our topic for the next blog!</p><img src=https://krshrimali.github.io/assets/opencv/imgPortraitBokehCroppingCircle.png><p>This should be it for this blog, and I hope you learnt something new today. If you liked the content, please leave a comment below. I would love to read your feedbacks, suggestions and if this helped you out in any way. I also go live on weekends, and upload videos on weekdays on my <a href=https://youtube.com/c/kushashwaraviShrimali>YouTube Channel</a>, so make sure to subscribe there and join me in if you find it interesting! Thank you for reading this blog.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://krshrimali.github.io/tags/computer-vision/>Computer Vision</a></li><li><a href=https://krshrimali.github.io/tags/python/>Python</a></li><li><a href=https://krshrimali.github.io/tags/portrait-bokeh/>Portrait Bokeh</a></li><li><a href=https://krshrimali.github.io/tags/image-processing/>Image Processing</a></li></ul><nav class=paginav><a class=prev href=https://krshrimali.github.io/posts/2021/07/function-pointers-and-function-objects-in-c-/><span class=title>« Prev</span><br><span>Function Pointers and Function Objects in C++</span>
</a><a class=next href=https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/><span class=title>Next »</span><br><span>Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on x" href="https://x.com/intent/tweet/?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&amp;hashtags=computervision%2cpython%2cportraitbokeh%2cimageprocessing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&amp;title=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;summary=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f&title=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on telegram" href="https://telegram.me/share/url?text=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20to%20crop%20a%20circle%20in%20OpenCV%3f%20Implementing%20Portrait%20Bokeh%20-%20Part%202&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fhow-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>