<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) | Kushashwa Ravi Shrimali (Kush)</title><meta name=keywords content="computer vision,python,portrait bokeh,image processing"><meta name=description content="
OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1)
This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We&rsquo;ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:

Using Face Detection (cropping a rectangle)
Using Face Detection (cropping a circle)
Using Facial Landmark Detection and Convex Hull

Don&rsquo;t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here."><meta name=author content="map[name:Kushashwa Ravi Shrimali]"><link rel=canonical href=https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/><link crossorigin=anonymous href=https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://krshrimali.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://krshrimali.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://krshrimali.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://krshrimali.github.io/apple-touch-icon.png><link rel=mask-icon href=https://krshrimali.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/"><meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)"><meta property="og:title" content="Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)"><meta property="og:description" content="
OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1) This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We’ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:
Using Face Detection (cropping a rectangle) Using Face Detection (cropping a circle) Using Facial Landmark Detection and Convex Hull Don’t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-07T00:00:00+00:00"><meta property="article:tag" content="Computer Vision"><meta property="article:tag" content="Python"><meta property="article:tag" content="Portrait Bokeh"><meta property="article:tag" content="Image Processing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)"><meta name=twitter:description content="
OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1)
This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We&rsquo;ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:

Using Face Detection (cropping a rectangle)
Using Face Detection (cropping a circle)
Using Facial Landmark Detection and Convex Hull

Don&rsquo;t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://krshrimali.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)","item":"https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)","name":"Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)","description":"\nOpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1) This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We\u0026rsquo;ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:\nUsing Face Detection (cropping a rectangle) Using Face Detection (cropping a circle) Using Facial Landmark Detection and Convex Hull Don\u0026rsquo;t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here.\n","keywords":["computer vision","python","portrait bokeh","image processing"],"articleBody":"\nOpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1) This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We’ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:\nUsing Face Detection (cropping a rectangle) Using Face Detection (cropping a circle) Using Facial Landmark Detection and Convex Hull Don’t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here.\nPortrait Bokeh: Discussing Problem Statement Before moving ahead, let’s talk about “What is Portrait Bokeh?”. It’s important to talk about the problem before discussing solutions. Take a quick look at the two images below:\nAs you might have spotted the difference already, the image on the left is our input (/original) image while the image on the right is our output image. If you haven’t spotted the difference, everything except the face in the image on the right is blurred! This feature now comes in almost all smart phones, and is also termed as just Portrait mode. Whenever you want to highlight the people near to the camera (mostly you, your friends or anyone) and blur the background, this is the mode you will usually choose. While some blur everything except faces, others might choose to keep the body instead of just faces. Our problem statement will be limited to faces here.\nMethodology opted Let’s discuss on how we can go ahead to solve this problem. We surely need to know where the face is to avoid blurring it, so the first step has to be of face detection. And since we need to blur the background, so at some stage, we need to do blurring as well. Since this part is about the simplest step, we can just combine them and say:\nDetect face(s) from the given input image. Crop the faces and store them as separate objects. Blur the whole image. Overlay the cropped faces from step-2 on the output from step-3. Video Tutorial I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven’t seen it before, please check it out here. For this blog, I have already uploaded a detailed tutorial. Check it out here.\nStep 1: Detecting Faces using Haarcascade We’ll be using haarcascade model files to detect face in the image. To ease the computation and satisfy the input to the model, we need to first convert the image to GrayScale (if it’s not already) - that is the image will now have only one channel instead of 3 (Blue, Green, Red). Download the model file to your directory from here. Let’s go ahead and initialize our Face Detector.\nmodel_path = \"haarcascade_frontalface_default.xml\" # Assuming this is in our current directory face_detector = cv2.CascadeClassifier(model_path) Once we have the model loaded, let’s go ahead and detect faces from the given image. Remember, that we will also convert the image to grayscale.\n# Read input image (get image path first from command line, else take sample.png - default) img_path = self.argv[1] if len(sys.argv) \u003e 1 else \"sample.png\" img = cv2.imread(img_path, 1) # Convert the image to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Get faces # Use default arguments, scaleFactor can be tweaked depending on the image # The output will be in format: [ [, , , : for face 1], [ ... : for face 2], ... ] faces = face_detector.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5) Once we have the faces, we can crop them and use in the Step-4 again. The output from face detection should look like this:\nStep 2: Crop faces To crop them and store in another object:\ncropped_faces = [] for face in faces: # Get points: tlx (top left x), tly (top left y), w (width), h (height) tlx, tly, w, h = face[0], face[1], face[2], face[3] cropped_faces.append( face[tly:tly+h, tlx:tlx+w] ) The list cropped_faces will now contain only faces. We can use this list again in Step-4!\nStep 3 and Step 4: Blur the image and overlay faces Let’s blur the whole image, and then overlay the images on the top of it. To blur, we will be using Gaussian Blur which works just fine.\nblur = cv2.GaussianBlur(img, (11, 11)) # Here, (11, 11) is the kernel size Once the whole image has been blurred, let’s overlay the cropped faces from Step 2.\nfor face_index, cropped_face in enumerate(cropped_faces): # Get face coordinates, to get ROI face_coords = faces[face_index] tlx, tly, w, h = face_coords[0], face_coords[1], face_coords[2], face_coords[3] # Overlay the ROI of face to the cropped face blur[tly:tly+h, tlx:tlx+w] = cropped_face Following image explains the procedure in details with visualization.\nAnd this is how the output (on the right) will look like (see below).\nWhile I know many of you will be thinking that it’s not accurate at all (since we can see the rectangle there), and that will be a topic for the next blog where we will attempt to crop a circle. Make sure to leave a comment if you have any suggestions, feedback or if this blog helped you in any way - I would love to hear that!\n","wordCount":"882","inLanguage":"en","datePublished":"2020-12-07T00:00:00Z","dateModified":"2020-12-07T00:00:00Z","author":{"@type":"Person","name":{"name":"Kushashwa Ravi Shrimali"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://krshrimali.github.io/posts/2020/12/implementing-portrait-bokeh-in-opencv-using-face-detection-part-1/"},"publisher":{"@type":"Organization","name":"Kushashwa Ravi Shrimali (Kush)","logo":{"@type":"ImageObject","url":"https://krshrimali.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://krshrimali.github.io/ accesskey=h title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://krshrimali.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://krshrimali.github.io/about title=About><span>About</span></a></li><li><a href=https://krshrimali.github.io/posts title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://krshrimali.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://krshrimali.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1)</h1><div class=post-meta><span title='2020-12-07 00:00:00 +0000 UTC'>December 7, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;map[name:Kushashwa Ravi Shrimali]</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#opencv-using-face-detection-for-portrait-bokeh-background-blur-part---1 aria-label="OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1)">OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1)</a><ul><li><a href=#portrait-bokeh-discussing-problem-statement aria-label="Portrait Bokeh: Discussing Problem Statement">Portrait Bokeh: Discussing Problem Statement</a></li><li><a href=#methodology-opted aria-label="Methodology opted">Methodology opted</a></li><li><a href=#video-tutorial aria-label="Video Tutorial">Video Tutorial</a></li><li><a href=#step-1-detecting-faces-using-haarcascade aria-label="Step 1: Detecting Faces using Haarcascade">Step 1: Detecting Faces using Haarcascade</a></li><li><a href=#step-2-crop-faces aria-label="Step 2: Crop faces">Step 2: Crop faces</a></li><li><a href=#step-3-and-step-4-blur-the-image-and-overlay-faces aria-label="Step 3 and Step 4: Blur the image and overlay faces">Step 3 and Step 4: Blur the image and overlay faces</a></li></ul></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Dec_7_2020.jpg></p><h1 id=opencv-using-face-detection-for-portrait-bokeh-background-blur-part---1>OpenCV: Using face detection for Portrait Bokeh (Background Blur) (Part - 1)<a hidden class=anchor aria-hidden=true href=#opencv-using-face-detection-for-portrait-bokeh-background-blur-part---1>#</a></h1><p>This blog discusses using Face Detection in OpenCV for Portrait Bokeh. We&rsquo;ll be implementing Portrait Bokeh (blurring everything but faces) using 3 different methods in this series:</p><ol><li>Using Face Detection (cropping a rectangle)</li><li>Using Face Detection (cropping a circle)</li><li>Using Facial Landmark Detection and Convex Hull</li></ol><p>Don&rsquo;t lose hopes if you are confused. We will be going through each method one by one, and hopefully the road will be crearer from here.</p><h2 id=portrait-bokeh-discussing-problem-statement>Portrait Bokeh: Discussing Problem Statement<a hidden class=anchor aria-hidden=true href=#portrait-bokeh-discussing-problem-statement>#</a></h2><p>Before moving ahead, let&rsquo;s talk about &ldquo;What is Portrait Bokeh?&rdquo;. It&rsquo;s important to talk about the problem before discussing solutions. Take a quick look at the two images below:</p><p><img src=https://krshrimali.github.io/assets/blogs/input_method1.jpeg> <img src=https://krshrimali.github.io/assets/blogs/output_final.jpg></p><p>As you might have spotted the difference already, the image on the left is our input (/original) image while the image on the right is our output image. If you haven&rsquo;t spotted the difference, everything except the face in the image on the right is blurred! This feature now comes in almost all smart phones, and is also termed as just Portrait mode. Whenever you want to highlight the people near to the camera (mostly you, your friends or anyone) and blur the background, this is the mode you will usually choose. While some blur everything except faces, others might choose to keep the body instead of just faces. Our problem statement will be limited to faces here.</p><h2 id=methodology-opted>Methodology opted<a hidden class=anchor aria-hidden=true href=#methodology-opted>#</a></h2><p>Let&rsquo;s discuss on how we can go ahead to solve this problem. We surely need to know where the face is to avoid blurring it, so the first step has to be of face detection. And since we need to blur the background, so at some stage, we need to do blurring as well. Since this part is about the simplest step, we can just combine them and say:</p><ol><li>Detect face(s) from the given input image.</li><li>Crop the faces and store them as separate objects.</li><li>Blur the whole image.</li><li>Overlay the cropped faces from step-2 on the output from step-3.</li></ol><h2 id=video-tutorial>Video Tutorial<a hidden class=anchor aria-hidden=true href=#video-tutorial>#</a></h2><p>I started a YouTube channel where I go live on the weekends, and upload videos on the week days (not so regularly) about Computer Vision, deploying models into production and more. If you haven&rsquo;t seen it before, please check it out <a href=https://youtube.com/c/kushashwaraviShrimali>here</a>. For this blog, I have already uploaded a detailed tutorial. Check it out <a href="https://www.youtube.com/watch?v=Nd3wFiSH-gw">here</a>.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Nd3wFiSH-gw?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h2 id=step-1-detecting-faces-using-haarcascade>Step 1: Detecting Faces using Haarcascade<a hidden class=anchor aria-hidden=true href=#step-1-detecting-faces-using-haarcascade>#</a></h2><p>We&rsquo;ll be using haarcascade model files to detect face in the image. To ease the computation and satisfy the input to the model, we need to first convert the image to GrayScale (if it&rsquo;s not already) - that is the image will now have only one channel instead of 3 (Blue, Green, Red). Download the model file to your directory from <a href=https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_frontalface_default.xml>here</a>. Let&rsquo;s go ahead and initialize our Face Detector.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>model_path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;haarcascade_frontalface_default.xml&#34;</span> <span style=color:#75715e># Assuming this is in our current directory</span>
</span></span><span style=display:flex><span>face_detector <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>CascadeClassifier(model_path)
</span></span></code></pre></div><p>Once we have the model loaded, let&rsquo;s go ahead and detect faces from the given image. Remember, that we will also convert the image to grayscale.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Read input image (get image path first from command line, else take sample.png - default)</span>
</span></span><span style=display:flex><span>img_path <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#34;sample.png&#34;</span>
</span></span><span style=display:flex><span>img <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(img_path, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Convert the image to grayscale</span>
</span></span><span style=display:flex><span>gray <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>cvtColor(img, cv2<span style=color:#f92672>.</span>COLOR_BGR2GRAY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Get faces</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Use default arguments, scaleFactor can be tweaked depending on the image</span>
</span></span><span style=display:flex><span><span style=color:#75715e># The output will be in format: [ [&lt;top left x coord&gt;, &lt;top left y&gt;, &lt;width&gt;, &lt;height&gt; : for face 1], [ ... : for face 2], ... ]</span>
</span></span><span style=display:flex><span>faces <span style=color:#f92672>=</span> face_detector<span style=color:#f92672>.</span>detectMultiScale(gray, scaleFactor<span style=color:#f92672>=</span><span style=color:#ae81ff>1.1</span>, minNeighbors<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><p>Once we have the faces, we can crop them and use in the Step-4 again. The output from face detection should look like this:</p><img src=https://krshrimali.github.io/assets/blogs/rect_sample_method1.jpeg><h2 id=step-2-crop-faces>Step 2: Crop faces<a hidden class=anchor aria-hidden=true href=#step-2-crop-faces>#</a></h2><p>To crop them and store in another object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cropped_faces <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> face <span style=color:#f92672>in</span> faces:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get points: tlx (top left x), tly (top left y), w (width), h (height)</span>
</span></span><span style=display:flex><span>    tlx, tly, w, h <span style=color:#f92672>=</span> face[<span style=color:#ae81ff>0</span>], face[<span style=color:#ae81ff>1</span>], face[<span style=color:#ae81ff>2</span>], face[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>    cropped_faces<span style=color:#f92672>.</span>append(
</span></span><span style=display:flex><span>        face[tly:tly<span style=color:#f92672>+</span>h, tlx:tlx<span style=color:#f92672>+</span>w]
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><p>The list <code>cropped_faces</code> will now contain only faces. We can use this list again in Step-4!</p><h2 id=step-3-and-step-4-blur-the-image-and-overlay-faces>Step 3 and Step 4: Blur the image and overlay faces<a hidden class=anchor aria-hidden=true href=#step-3-and-step-4-blur-the-image-and-overlay-faces>#</a></h2><p>Let&rsquo;s blur the whole image, and then overlay the images on the top of it. To blur, we will be using Gaussian Blur which works just fine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>blur <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>GaussianBlur(img, (<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>11</span>)) <span style=color:#75715e># Here, (11, 11) is the kernel size</span>
</span></span></code></pre></div><p>Once the whole image has been blurred, let&rsquo;s overlay the cropped faces from <code>Step 2</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> face_index, cropped_face <span style=color:#f92672>in</span> enumerate(cropped_faces):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get face coordinates, to get ROI</span>
</span></span><span style=display:flex><span>    face_coords <span style=color:#f92672>=</span> faces[face_index]
</span></span><span style=display:flex><span>    tlx, tly, w, h <span style=color:#f92672>=</span> face_coords[<span style=color:#ae81ff>0</span>], face_coords[<span style=color:#ae81ff>1</span>], face_coords[<span style=color:#ae81ff>2</span>], face_coords[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Overlay the ROI of face to the cropped face</span>
</span></span><span style=display:flex><span>    blur[tly:tly<span style=color:#f92672>+</span>h, tlx:tlx<span style=color:#f92672>+</span>w] <span style=color:#f92672>=</span> cropped_face
</span></span></code></pre></div><p>Following image explains the procedure in details with visualization.</p><img src=https://krshrimali.github.io/assets/blogs/procedure_method1.jpg><p>And this is how the output (on the right) will look like (see below).</p><img src=https://krshrimali.github.io/assets/blogs/output_method1.jpg><p>While I know many of you will be thinking that it&rsquo;s not accurate at all (since we can see the rectangle there), and that will be a topic for the next blog where we will attempt to crop a circle. Make sure to leave a comment if you have any suggestions, feedback or if this blog helped you in any way - I would love to hear that!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://krshrimali.github.io/tags/computer-vision/>Computer Vision</a></li><li><a href=https://krshrimali.github.io/tags/python/>Python</a></li><li><a href=https://krshrimali.github.io/tags/portrait-bokeh/>Portrait Bokeh</a></li><li><a href=https://krshrimali.github.io/tags/image-processing/>Image Processing</a></li></ul><nav class=paginav><a class=prev href=https://krshrimali.github.io/posts/2020/12/how-to-crop-a-circle-in-opencv-implementing-portrait-bokeh-part-2/><span class=title>« Prev</span><br><span>How to crop a circle in OpenCV? Implementing Portrait Bokeh - Part 2</span>
</a><a class=next href=https://krshrimali.github.io/posts/2020/09/releasing-docker-container-and-binder-for-using-xeus-cling-libtorch-and-opencv-in-c-/><span class=title>Next »</span><br><span>Releasing Docker Container and Binder for using Xeus-Cling, Libtorch and OpenCV in C++</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on x" href="https://x.com/intent/tweet/?text=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f&amp;hashtags=computervision%2cpython%2cportraitbokeh%2cimageprocessing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f&amp;title=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29&amp;summary=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f&title=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on whatsapp" href="https://api.whatsapp.com/send?text=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on telegram" href="https://telegram.me/share/url?text=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing Portrait Bokeh in OpenCV using Face Detection (Part-1) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Implementing%20Portrait%20Bokeh%20in%20OpenCV%20using%20Face%20Detection%20%28Part-1%29&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2020%2f12%2fimplementing-portrait-bokeh-in-opencv-using-face-detection-part-1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>