<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Common Collections (Vector and Strings) in Rust [Notes] | Kushashwa Ravi Shrimali (Kush)</title>
<meta name="keywords" content="development, coding, rust, notes">
<meta name="description" content="Chapter 8: Common Collections (Hash Maps)
In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we&rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we&rsquo;ll see lots of use-cases in real-life problems.
Hash Maps
Hash Maps: HashMap&lt;K, V&gt;

You can&rsquo;t access using indices, but through keys.
Hash Maps store data on heap.
Hash Maps are homogenous (all keys must have same type, and all values must have same type).
Use std::collections::HashMap to bring HashMap to scope.

Creating a New Hash Map">
<meta name="author" content="map[name:Kushashwa Ravi Shrimali]">
<link rel="canonical" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
<link crossorigin="anonymous" href="https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://krshrimali.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://krshrimali.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://krshrimali.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://krshrimali.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://krshrimali.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
  <meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)">
  <meta property="og:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta property="og:description" content="Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we’ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we’ll see lots of use-cases in real-life problems.
Hash Maps Hash Maps: HashMap&lt;K, V&gt;
You can’t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-01-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-01-09T00:00:00+00:00">
    <meta property="article:tag" content="Development">
    <meta property="article:tag" content="Coding">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
<meta name="twitter:description" content="Chapter 8: Common Collections (Hash Maps)
In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we&rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we&rsquo;ll see lots of use-cases in real-life problems.
Hash Maps
Hash Maps: HashMap&lt;K, V&gt;

You can&rsquo;t access using indices, but through keys.
Hash Maps store data on heap.
Hash Maps are homogenous (all keys must have same type, and all values must have same type).
Use std::collections::HashMap to bring HashMap to scope.

Creating a New Hash Map">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://krshrimali.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Common Collections (Vector and Strings) in Rust [Notes]",
      "item": "https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Common Collections (Vector and Strings) in Rust [Notes]",
  "name": "Common Collections (Vector and Strings) in Rust [Notes]",
  "description": "Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we\u0026rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we\u0026rsquo;ll see lots of use-cases in real-life problems.\nHash Maps Hash Maps: HashMap\u0026lt;K, V\u0026gt;\nYou can\u0026rsquo;t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map\n",
  "keywords": [
    "development", "coding", "rust", "notes"
  ],
  "articleBody": "Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we’ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we’ll see lots of use-cases in real-life problems.\nHash Maps Hash Maps: HashMap\nYou can’t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map\nFirst Way:\nuse std::collections::HashMap; let mut scores = HashMap::new(); // Now insert key, val pair scores.insert(\"Kush\", 3); scores.insert(\"Kushashwa\", 10); Second Way: In case you have keys and values stored in two different vectors, and want to generate a hashmap from them, use collect().\nuse std::collections::HashMap; let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")]; let initial_scores = vec![10, 50]; // Types will be infered by Rust from the data in the vectors let mut scores: HashMap\u003c_, _\u003e = teams.into_iter().zip(initial_scores.into_iter()).collect(); Why HashMap\u003c_, _\u003e? collect() method can store values into different datastructures, and we need to specify the type of scores. For the types of keys and values, Rust can infer the types itself - hence we specify _.\nI was curious what into_iter() does, and here is a very interesting answer to into_iter() vs iter() on Stackoverflow. Someone mentioned this blog post in the comments, I’ve this as a TODO - but from the looks of it, it might be useful.\nIf you are curious what teams.into_iter().zip(initial_scores.into_iter()) do? Great, check this:\nfn main() { let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")]; let initial_scores = vec![10, 50]; let tuple_output = teams.into_iter().zip(initial_scores.into_iter()); for item in tuple_output { println!(\"{}, {}\" ,item.0, item.1); } } Outputs:\nBlue, 10 Yellow, 50 So clearly, creating a vector of tuples (of a String and Integer). Maybe try passing a vector of different length to .zip() function? ;)\nHash Maps and Ownership Ownership is always the center of discussion when it comes to Rust. When you create a hashmap, and insert String objects, i32 values, the ownership behaves differently:\nFor types that implement Copy trait, like i32, the values will be copied to the hashmap. For String values (owned values), the values are moved into the hashmap and the hashmap will be the owner. See the following example and corresponding error:\nuse std::collections::HashMap; fn main() { let str1 = String::from(\"Kush\"); let str2 = String::from(\"Name\"); let mut map = HashMap::new(); map.insert(str1, str2); println!(\"{}\", str1); } | 4 | let str1 = String::from(\"Kush\"); | ---- move occurs because `str1` has type `String`, which does not implement the `Copy` trait ... 8 | map.insert(str1, str2); | ---- value moved here 9 | 10 | println!(\"{}\", str1); | ^^^^ value borrowed here after move As you can see, value was moved when map.insert(str1, str2) was called. One important point, that I’ll just take from the book:\nIf we insert references to values into the hash map, the values won’t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid.\n(This is covered in detail in Chapter 10, so let’s save it for later).\nAccessing Values in a Hash Map Use .get() function to get the value corresponding to the key. Please note that it returns Option\u003c\u0026V\u003e where V is the type of the value.\nuse std::collections::HashMap; fn main() { let str1 = String::from(\"Kush\"); let str2 = String::from(\"Name\"); let mut map = HashMap::new(); map.insert(str1, str2); let val = map.get(\u0026String::from(\"Kush\")); println!(\"{}\", val.unwrap()); } Outputs: Name.\nSince map.get(\u0026String::from(\"Kush\")) returns Option\u003c\u0026String\u003e object, we need to unwrap() it in order to print it. Here is an interesting post on why using unwrap() is not the best idea, and what other options we have. I used unwrap() here, since I knew it is not None.\nIterating through a hash map is also easy in Rust:\n// Use the same code as above for (key, value) in \u0026map { println!(\"{}: {}\", key, value); } // Output: // Kush: Name Updating a Hash Map Note that you can only have one value corresponding to a key. Let’s consider our options:\nOverwriting a value: insert() twice, and the new value will replace the old value.\nOnly insert if key has no value:\nUse entry(), it returns an Enum: Empty (represents a value that might or might not exist). Call or_insert on the enum, which inserts a value if key doesn’t exist. or_insert returns a mutable reference to the value present, or to the new value inserted. use std::collections::HashMap; fn main() { let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10); scores.entry(String::from(\"Yellow\")).or_insert(50); scores.entry(String::from(\"Blue\")).or_insert(50); println!(\"{:?}\", scores); } // Outputs // {\"Blue\": 10, \"Yellow\": 50} Updating a value based on the old value: Comments in the code should help explain the example.\nuse std::collections::HashMap; fn main() { let text = \"hello world wonderful world\"; let mut map = HashMap::new(); // \"hello\", \"world\", \"wonderful\", \"world\" - values of word for word in text.split_whitespace() { // if the map has an entry for word, return the count of it // else, insert 0 and increase the counter by 1 // note that count is mutable reference // so it needs to be de-referenced (in order to use it) let count = map.entry(word).or_insert(0); *count += 1; } println!(\"{:?}\", map); } // Outputs: // {\"world\": 2, \"wonderful\": 1, \"hello\": 1} Hashing Functions By default, Hash Maps in Rust use SipHash hashing function, but you can use your own as well - it should implement BuildHasher trait. More on this is discussed in Chapter 10.\nThat’s it for Chapter 8, thank you for reading. :)\nNote These are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone’s and also my memory. At no point I say or mean that these should be preferred or read “over” the original resource mentioned. But as always, I’m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).\n",
  "wordCount" : "1020",
  "inLanguage": "en",
  "datePublished": "2022-01-09T00:00:00Z",
  "dateModified": "2022-01-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": {"name":"Kushashwa Ravi Shrimali"}
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kushashwa Ravi Shrimali (Kush)",
    "logo": {
      "@type": "ImageObject",
      "url": "https://krshrimali.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://krshrimali.github.io/" accesskey="h" title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://krshrimali.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://krshrimali.github.io/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://krshrimali.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://krshrimali.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Common Collections (Vector and Strings) in Rust [Notes]
    </h1>
    <div class="post-meta"><span title='2022-01-09 00:00:00 +0000 UTC'>January 9, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;map[name:Kushashwa Ravi Shrimali]

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#chapter-8-common-collections-hash-maps" aria-label="Chapter 8: Common Collections (Hash Maps)">Chapter 8: Common Collections (Hash Maps)</a></li>
                <li>
                    <a href="#hash-maps" aria-label="Hash Maps">Hash Maps</a></li>
                <li>
                    <a href="#hash-maps-and-ownership" aria-label="Hash Maps and Ownership">Hash Maps and Ownership</a></li>
                <li>
                    <a href="#accessing-values-in-a-hash-map" aria-label="Accessing Values in a Hash Map">Accessing Values in a Hash Map</a></li>
                <li>
                    <a href="#updating-a-hash-map" aria-label="Updating a Hash Map">Updating a Hash Map</a></li>
                <li>
                    <a href="#hashing-functions" aria-label="Hashing Functions">Hashing Functions</a></li>
                <li>
                    <a href="#note" aria-label="Note">Note</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="chapter-8-common-collections-hash-maps">Chapter 8: Common Collections (Hash Maps)<a hidden class="anchor" aria-hidden="true" href="#chapter-8-common-collections-hash-maps">#</a></h2>
<p>In the <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">previous blog</a>, I shared my notes on strings and vectors in Rust, and in this post we&rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we&rsquo;ll see lots of use-cases in real-life problems.</p>
<h2 id="hash-maps">Hash Maps<a hidden class="anchor" aria-hidden="true" href="#hash-maps">#</a></h2>
<p>Hash Maps: <code>HashMap&lt;K, V&gt;</code></p>
<ul>
<li>You can&rsquo;t access using indices, but through keys.</li>
<li>Hash Maps store data on heap.</li>
<li>Hash Maps are homogenous (all keys must have same type, and all values must have same type).</li>
<li>Use <code>std::collections::HashMap</code> to bring <code>HashMap</code> to scope.</li>
</ul>
<p><strong>Creating a New Hash Map</strong></p>
<p>First Way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now insert key, val pair
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>scores.insert(<span style="color:#e6db74">&#34;Kush&#34;</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>scores.insert(<span style="color:#e6db74">&#34;Kushashwa&#34;</span>, <span style="color:#ae81ff">10</span>);
</span></span></code></pre></div><p>Second Way: In case you have keys and values stored in two different vectors, and want to generate a hashmap from them, use <code>collect()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> teams <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> initial_scores <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Types will be infered by Rust from the data in the vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>_, _<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> teams.into_iter().zip(initial_scores.into_iter()).collect();
</span></span></code></pre></div><p>Why <code>HashMap&lt;_, _&gt;</code>? <code>collect()</code> method can store values into different datastructures, and we need to specify the type of <code>scores</code>. For the types of keys and values, Rust can infer the types itself - hence we specify <code>_</code>.</p>
<p>I was curious what <code>into_iter()</code> does, and <a href="https://stackoverflow.com/a/34745885">here</a> is a very interesting answer to <code>into_iter()</code> vs <code>iter()</code> on Stackoverflow. Someone mentioned <a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html/">this blog post</a> in the comments, I&rsquo;ve this as a TODO - but from the looks of it, it might be useful.</p>
<p>If you are curious what <code>teams.into_iter().zip(initial_scores.into_iter())</code> do? Great, check this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> teams <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> initial_scores <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tuple_output <span style="color:#f92672">=</span> teams.into_iter().zip(initial_scores.into_iter());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> tuple_output {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span> ,item.<span style="color:#ae81ff">0</span>, item.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Outputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Blue, <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>Yellow, <span style="color:#ae81ff">50</span>
</span></span></code></pre></div><p>So clearly, creating a vector of tuples (of a <code>String</code> and <code>Integer</code>). Maybe try passing a vector of different length to <code>.zip()</code> function? ;)</p>
<h2 id="hash-maps-and-ownership">Hash Maps and Ownership<a hidden class="anchor" aria-hidden="true" href="#hash-maps-and-ownership">#</a></h2>
<p>Ownership is always the center of discussion when it comes to Rust. When you create a hashmap, and insert <code>String</code> objects, <code>i32</code> values, the ownership behaves differently:</p>
<ol>
<li>For types that implement <code>Copy</code> trait, like <code>i32</code>, the values will be copied to the hashmap.</li>
<li>For <code>String</code> values (owned values), the values are moved into the hashmap and the hashmap will be the owner.</li>
</ol>
<p>See the following example and corresponding error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    map.insert(str1, str2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, str1);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>  <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>         <span style="color:#f92672">----</span> <span style="color:#66d9ef">move</span> occurs because <span style="color:#960050;background-color:#1e0010">`</span>str1<span style="color:#960050;background-color:#1e0010">`</span> has <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>, which does not implement the <span style="color:#960050;background-color:#1e0010">`</span>Copy<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">trait</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>  <span style="color:#f92672">|</span>     map.insert(str1, str2);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>                <span style="color:#f92672">----</span> value moved here
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>  <span style="color:#f92672">|</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> <span style="color:#f92672">|</span>     <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, str1);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>                    <span style="color:#f92672">^^^^</span> value borrowed here after <span style="color:#66d9ef">move</span>
</span></span></code></pre></div><p>As you can see, value was moved when <code>map.insert(str1, str2)</code> was called. One important point, that I&rsquo;ll just take from the book:</p>
<blockquote>
<p>If we insert references to values into the hash map, the values won’t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid.</p></blockquote>
<p>(This is covered in detail in Chapter 10, so let&rsquo;s save it for later).</p>
<h2 id="accessing-values-in-a-hash-map">Accessing Values in a Hash Map<a hidden class="anchor" aria-hidden="true" href="#accessing-values-in-a-hash-map">#</a></h2>
<p>Use <code>&lt;HashMap&gt;.get(&lt;Key&gt;)</code> function to get the value corresponding to the key. Please note that it returns <code>Option&lt;&amp;V&gt;</code> where <code>V</code> is the type of the value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    map.insert(str1, str2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> val <span style="color:#f92672">=</span> map.get(<span style="color:#f92672">&amp;</span>String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, val.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Outputs: <code>Name</code>.</p>
<p>Since <code>map.get(&amp;String::from(&quot;Kush&quot;))</code> returns <code>Option&lt;&amp;String&gt;</code> object, we need to <code>unwrap()</code> it in order to print it. Here is <a href="https://www.ameyalokare.com/rust/2017/10/23/rust-options.html">an interesting post</a> on why using <code>unwrap()</code> is not the best idea, and what other options we have. I used <code>unwrap()</code> here, since I knew it is not <code>None</code>.</p>
<p>Iterating through a hash map is also easy in Rust:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Use the same code as above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (key, value) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>map {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, key, value);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Kush: Name
</span></span></span></code></pre></div><h2 id="updating-a-hash-map">Updating a Hash Map<a hidden class="anchor" aria-hidden="true" href="#updating-a-hash-map">#</a></h2>
<p>Note that you can only have one value corresponding to a key. Let&rsquo;s consider our options:</p>
<ol>
<li>
<p><strong>Overwriting a value</strong>: <code>insert()</code> twice, and the new value will replace the old value.</p>
</li>
<li>
<p><strong>Only insert if key has no value</strong>:</p>
<ul>
<li>Use <code>entry(&lt;Key&gt;)</code>, it returns an <code>Enum</code>: <code>Empty</code> (represents a value that might or might not exist).</li>
<li>Call <code>or_insert</code> on the enum, which inserts a value if key doesn&rsquo;t exist.</li>
<li><code>or_insert</code> returns a mutable reference to the value present, or to the new value inserted.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    scores.insert(String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    scores.entry(String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)).or_insert(<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>    scores.entry(String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>)).or_insert(<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, scores);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Outputs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {&#34;Blue&#34;: 10, &#34;Yellow&#34;: 50}
</span></span></span></code></pre></div></li>
<li>
<p><strong>Updating a value based on the old value</strong>: Comments in the code should help explain the example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world wonderful world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// &#34;hello&#34;, &#34;world&#34;, &#34;wonderful&#34;, &#34;world&#34; - values of word
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> word <span style="color:#66d9ef">in</span> text.split_whitespace() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if the map has an entry for word, return the count of it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// else, insert 0 and increase the counter by 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// note that count is mutable reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// so it needs to be de-referenced (in order to use it)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> map.entry(word).or_insert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, map); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Outputs:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {&#34;world&#34;: 2, &#34;wonderful&#34;: 1, &#34;hello&#34;: 1}
</span></span></span></code></pre></div></li>
</ol>
<h2 id="hashing-functions">Hashing Functions<a hidden class="anchor" aria-hidden="true" href="#hashing-functions">#</a></h2>
<p>By default, Hash Maps in Rust use <a href="https://en.wikipedia.org/wiki/SipHash"><code>SipHash</code></a> hashing function, but you can use your own as well - it should implement <code>BuildHasher</code> trait. More on this is discussed in Chapter 10.</p>
<p>That&rsquo;s it for Chapter 8, thank you for reading. :)</p>
<h2 id="note">Note<a hidden class="anchor" aria-hidden="true" href="#note">#</a></h2>
<hr>
<p>These are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone&rsquo;s and also my memory. At no point I say or mean that these should be preferred or read &ldquo;over&rdquo; the original resource mentioned. But as always, I&rsquo;m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://krshrimali.github.io/tags/development/">Development</a></li>
      <li><a href="https://krshrimali.github.io/tags/coding/">Coding</a></li>
      <li><a href="https://krshrimali.github.io/tags/rust/">Rust</a></li>
      <li><a href="https://krshrimali.github.io/tags/notes/">Notes</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
    <span class="title">« Prev</span>
    <br>
    <span>Common Collections (Vector and Strings) in Rust [Notes]</span>
  </a>
  <a class="next" href="https://krshrimali.github.io/posts/2021/10/weekly-progress-report-03-10-2021-2/">
    <span class="title">Next »</span>
    <br>
    <span>Weekly Progress Report: 03-10-2021, 2</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on x"
            href="https://x.com/intent/tweet/?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&amp;hashtags=development%2ccoding%2crust%2cnotes">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&amp;title=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;summary=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&title=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on whatsapp"
            href="https://api.whatsapp.com/send?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on telegram"
            href="https://telegram.me/share/url?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
