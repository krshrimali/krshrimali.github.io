<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:Kushashwa Ravi Shrimali]">
<meta name="description" content="Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors Vec&lt;T&gt; collection type discussed, aka vector: * By default contiguous. * All values should be of same type.
// Creation let v: Vec&lt;i32&gt; = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // &lt;-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: &amp;i32 = &amp;v[2]; println!(&#34;The third element is: {}&#34;, third); // Second way: match v.get(2) { Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num), None =&gt; println!(&#34;There is no third element.&#34;), } .get(&amp;index) method allows you to handle out of range errors.
" />
<meta name="keywords" content=", development, coding, rust, notes" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/" />


    <title>
        
            Common Collections (Vector and Strings) in Rust [Notes] :: Kushashwa Ravi Shrimali (Kush)  — Learning never stops!
        
    </title>





  <link rel="stylesheet" href="https://krshrimali.github.io/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css" integrity="sha256-JEGDzeGjjgsI&#43;CwReRGBKI&#43;arBzJYYzW9OnncQxXaLo=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="https://krshrimali.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://krshrimali.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://krshrimali.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://krshrimali.github.io/site.webmanifest">
    <link rel="mask-icon" href="https://krshrimali.github.io/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://krshrimali.github.io/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta itemprop="description" content="Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors Vec&lt;T&gt; collection type discussed, aka vector: * By default contiguous. * All values should be of same type.
// Creation let v: Vec&lt;i32&gt; = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // &lt;-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: &amp;i32 = &amp;v[2]; println!(&#34;The third element is: {}&#34;, third); // Second way: match v.get(2) { Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num), None =&gt; println!(&#34;There is no third element.&#34;), } .get(&amp;index) method allows you to handle out of range errors.">
  <meta itemprop="datePublished" content="2022-01-09T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-01-09T00:00:00+00:00">
  <meta itemprop="wordCount" content="1535">
  <meta itemprop="image" content="https://krshrimali.github.io/">
  <meta itemprop="keywords" content="Development,Coding,Rust,Notes">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://krshrimali.github.io/">
  <meta name="twitter:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta name="twitter:description" content="Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors Vec&lt;T&gt; collection type discussed, aka vector: * By default contiguous. * All values should be of same type.
// Creation let v: Vec&lt;i32&gt; = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // &lt;-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: &amp;i32 = &amp;v[2]; println!(&#34;The third element is: {}&#34;, third); // Second way: match v.get(2) { Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num), None =&gt; println!(&#34;There is no third element.&#34;), } .get(&amp;index) method allows you to handle out of range errors.">





    <meta property="article:section" content="rust" />



    <meta property="article:published_time" content="2022-01-09 00:00:00 &#43;0000 UTC" />









    



    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://krshrimali.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                $ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://krshrimali.github.io/about">About</a></li><li><a href="https://krshrimali.github.io/posts">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        8 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">Common Collections (Vector and Strings) in Rust [Notes]</a>
      </h1>

      

      
        <hr />
        <aside id="toc">
          <div class="toc-title">Table of Contents</div>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#chapter-8-common-collections">Chapter 8: Common Collections</a>
      <ul>
        <li><a href="#81-storing-lists-of-values-with-vectors">8.1: Storing Lists of Values with Vectors</a></li>
        <li><a href="#82-storing-utf-8-encoded-text-with-strings">8.2: Storing UTF-8 Encoded Text with Strings</a></li>
      </ul>
    </li>
    <li><a href="#note">Note</a></li>
  </ul>
</nav>
        </aside>
        <hr />

      

      <div class="post-content">
        <h2 id="chapter-8-common-collections">Chapter 8: Common Collections</h2>
<p>These are my notes from the <a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html">chapter-8</a> of <a href="https://doc.rust-lang.org/book">rust book</a>. Please scroll down to the bottom (<code>Note</code>) section if you are curious about what this is.</p>
<h3 id="81-storing-lists-of-values-with-vectors">8.1: Storing Lists of Values with Vectors</h3>
<p><code>Vec&lt;T&gt;</code> collection type discussed, aka vector:
* By default contiguous.
* All values should be of same type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Creation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// vec! macro for convenience
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// default integer type is i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Modifying
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Rust infers the type from the elements pushed here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>v.push(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>v.push(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dropping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a vector is freed, when it goes out of scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// &lt;-- v goes out of scope here, and hence memory is freed as well
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reading Elements of Vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// First way:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> third: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;The third element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, third);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Second way:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> v.get(<span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>    Some(num) <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;The third element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, num),
</span></span><span style="display:flex;"><span>    None <span style="color:#f92672">=&gt;</span> println!(<span style="color:#e6db74">&#34;There is no third element.&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>.get(&amp;index)</code> method allows you to handle out of range errors.</p>
<blockquote>
<p>When a program has a valid reference, the borrow checker enforces the ownership and borrowing rules to ensure this reference and any other references to the contents of the vector remain valid.</p>
</blockquote>
<p>Following example will fail:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> first <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>v.push(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;The first element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, first);
</span></span></code></pre></div><ul>
<li>Adding an element to a vector may require the old memory chunk to be transferred to a new space, causing old memory disallocation for the object <code>v</code>.</li>
<li>Accessing <code>&amp;v[0]</code> can thus be dangerous, and hence the borrowing rules prevent programs from ending up in that situation.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Iterating over the values in a vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// get immutable references to each element in a vector v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>v {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// get mutable references to each element in a mutable veector v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">50</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can use an <code>enum</code> to store multiple type values in a vector, but indirectly, this is how:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">SpreadsheetCell</span> {
</span></span><span style="display:flex;"><span>    Int(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>    Float(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>    Text(String),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> row <span style="color:#f92672">=</span> vec![
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Int(<span style="color:#ae81ff">3</span>),
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Text(String::from(<span style="color:#e6db74">&#34;blue&#34;</span>)),
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Float(<span style="color:#ae81ff">10.12</span>),
</span></span><span style="display:flex;"><span>];
</span></span></code></pre></div><p>Note how <code>row</code> vector still has same types (of <code>enum SpreadsheetCell</code>) but can hold values of multiple types through enums.</p>
<h3 id="82-storing-utf-8-encoded-text-with-strings">8.2: Storing UTF-8 Encoded Text with Strings</h3>
<p>In Rust, strings are implemented as a collection of bytes + some methods to provide useful functionality when those bytes are interpreted as text.</p>
<p>(both types listed below are UTF-8 encoded)</p>
<ul>
<li>Rust has only one string type in the <strong>core language</strong>: string slice <code>str</code> (usually seen in borrowed form: <code>&amp;str</code>).</li>
<li>Rust&rsquo;s standard library provides <code>String</code> type: (not coded into the core language):
<ul>
<li>It&rsquo;s <em>growbable, mutable, and owned</em> UTF-8 encoded string type.</li>
</ul>
</li>
</ul>
<p>There are other string types included in Rust&rsquo;s standard library: <code>OsString, OsStr, CString, CStr&quot;. Types ending with </code>String<code>refer to owned variants, while types ending with</code>Str` refer to borrowed variants. (not discussed in the book/chapter)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Creating a new string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If you have some initial data, use to_string method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// this is available on any type that implements the Display trait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Following three methods are valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// First
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;initial contents&#34;</span>; <span style="color:#75715e">// a string literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> data.to_string();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;initial conents&#34;</span>.to_string();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Third
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;initial contents&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Updating a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push_str(<span style="color:#e6db74">&#34;bar&#34;</span>); <span style="color:#75715e">// s is now &#34;foobar&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Appending to a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// using push_str and push
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push_str(<span style="color:#e6db74">&#34;bar&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bar&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We don&#39;t take ownership of s2 here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// To ensure that we can still use s2 even after appending contents to s1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>s1.push_str(s2);
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;s2 is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s2);
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;s1 is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Use push to append single character to the String
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;lo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push(<span style="color:#e6db74">&#39;l&#39;</span>); <span style="color:#75715e">// now &#34;lol&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Concatenation with + operator or the format! macro
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, &#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span></code></pre></div><p>Consider the following script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34; bar&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The operation takes ownership of s1 here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You can not use s1 after the operation above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;s3 is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s3);
</span></span></code></pre></div><p>Following is the error you&rsquo;ll get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0382]: <span style="color:#a6e22e">borrow</span> of moved value: <span style="color:#960050;background-color:#1e0010">`</span>s1<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">27</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>         <span style="color:#f92672">--</span> <span style="color:#66d9ef">move</span> occurs because <span style="color:#960050;background-color:#1e0010">`</span>s1<span style="color:#960050;background-color:#1e0010">`</span> has <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>, which does not implement the <span style="color:#960050;background-color:#1e0010">`</span>Copy<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">trait</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34; bar&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>              <span style="color:#f92672">--</span> value moved here
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span>     println!(<span style="color:#e6db74">&#34;s1 is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>                           <span style="color:#f92672">^^</span> value borrowed here after <span style="color:#66d9ef">move</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>For more information about this error, <span style="color:#66d9ef">try</span> <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">--</span>explain E0382<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p>So what&rsquo;s happening? The <code>+</code> operator uses an <code>add</code> method whose signature looks like this for our inputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>A few notes about <code>s</code> parameter:</p>
<ol>
<li>It&rsquo;s taken by reference. Means you add reference of the second string to the firstt string.</li>
<li>You can not add 2 <code>String</code> values together, only <code>&amp;str</code> to a <code>String</code>. (Rust compiler, in our case, coerces the <code>&amp;String</code> argument into a <code>&amp;str</code>, more on deref coercion later).</li>
</ol>
<p>Note about <code>self</code> parameter:</p>
<ol>
<li><code>add</code> method takes ownership of <code>self</code> (it doesn&rsquo;t have an <code>&amp;</code>).</li>
<li>The point above implies, <code>s1</code> will be moved to the <code>add</code> call and no longer be valid after that.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span></code></pre></div><p>The above statement actually:</p>
<ol>
<li>Moves <code>s1</code> into the <code>add</code> call / takes ownership of <code>s1</code> (making it invalid after that)</li>
<li>Appends a <em>copy</em> of the contents of <code>s2</code>.</li>
<li>Returns ownership of the result.</li>
</ol>
<p>(this process is more efficient than copying).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Concatenating multiple strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;tic&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;tac&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;toe&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2 <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You can also do:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Uses reference for all parameters, so no ownership of any here...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1, s2, s3);
</span></span></code></pre></div><p>Talking about Indexing into Strings:</p>
<p>The following will give an error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Indexing into Strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Not like other languages (C++/Python):
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> s1[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>Error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0277]: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span> cannot be indexed by <span style="color:#960050;background-color:#1e0010">`</span>{integer}<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> s1[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>             <span style="color:#f92672">^^^^^</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span> cannot be indexed by <span style="color:#960050;background-color:#1e0010">`</span>{integer}<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">=</span> help: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">trait</span> <span style="color:#960050;background-color:#1e0010">`</span>Index<span style="color:#f92672">&lt;</span>{integer}<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> is not implemented <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p><em>Rust strings don&rsquo;t support indexing</em>. To understand, let&rsquo;s understand how memory storage works for strings in Rust.</p>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Consider:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Hola is 4 bytes long (each of the chars take 1 byte when encoded in UTF-8) and len will be 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hola&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now consider:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Здравствуйте&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Number of bytes stored for hello: 24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Each unicode scalar value in the string above takes 2 bytes of storage.
</span></span></span></code></pre></div><p>Hence, indexing into string&rsquo;s bytes will not always correlate to a valid Unicode scalar value. Hence, no indexing support for strings in Rust.</p>
<blockquote>
<p>A final reason Rust doesn’t allow us to index into a String to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</p>
</blockquote>
<p>Slicing strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Здравствуйте&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This will give you first 4 bytes of hello string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hello[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In hello, every character is of 2 bytes, so s will have Зд
</span></span></span></code></pre></div><p>With the same <code>hello</code> string, what will be the output if we used <code>let s = &amp;hello[0..1];</code>? Following error will be raised:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>thread <span style="color:#a6e22e">&#39;main&#39;</span> panicked at <span style="color:#a6e22e">&#39;byte</span> index <span style="color:#ae81ff">1</span> is not a <span style="color:#66d9ef">char</span> boundary; it is inside <span style="color:#e6db74">&#39;З&#39;</span> (bytes <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>) of <span style="color:#960050;background-color:#1e0010">`Здравствуйте`</span><span style="color:#a6e22e">&#39;</span>, src<span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">13</span>
</span></span></code></pre></div><p>Iterating over strings: use the <code>chars</code> method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;नमस्ते&#34;</span>.chars() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  न
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  म
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  स
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   ्
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  त
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   े
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// bytes method will return each raw byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> b <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;नमस्ते&#34;</span>.bytes() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// All 18 bytes that made up this string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 168
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 174
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 184
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 165
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 141
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 165
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 135
</span></span></span></code></pre></div><p>Note: valid unicode scalar values maybe made up of more than 1 byte, like above.</p>
<h2 id="note">Note</h2>
<hr>
<p><strong>NOTE</strong></p>
<p>These are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone&rsquo;s and also my memory. At no point I say or mean that these should be preferred or read &ldquo;over&rdquo; the original resource mentioned. But as always, I&rsquo;m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).</p>
<hr>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://krshrimali.github.io/tags/development/">development</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/coding/">coding</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/rust/">rust</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/notes/">notes</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://krshrimali.github.io/categories/rust/">rust</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        1535 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2022-01-09 05:30 &#43;0530
        

         
          
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-1/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Porting a Tiling Window Manager Extenstion to C&#43;&#43; (Bismuth): Part-1</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
                    <span class="button__text">Common Collections (Vector and Strings) in Rust [Notes]</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="https://krshrimali.github.io/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
