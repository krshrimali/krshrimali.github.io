<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:Kushashwa Ravi Shrimali]">
<meta name="description" content="Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we&rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we&rsquo;ll see lots of use-cases in real-life problems.
Hash Maps Hash Maps: HashMap&lt;K, V&gt;
You can&rsquo;t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map
" />
<meta name="keywords" content=", development, coding, rust, notes" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/" />


    <title>
        
            Common Collections (Vector and Strings) in Rust [Notes] :: Kushashwa Ravi Shrimali (Kush)  — Learning never stops!
        
    </title>





  <link rel="stylesheet" href="https://krshrimali.github.io/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css" integrity="sha256-JEGDzeGjjgsI&#43;CwReRGBKI&#43;arBzJYYzW9OnncQxXaLo=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="https://krshrimali.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://krshrimali.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://krshrimali.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://krshrimali.github.io/site.webmanifest">
    <link rel="mask-icon" href="https://krshrimali.github.io/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://krshrimali.github.io/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta itemprop="description" content="Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we’ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we’ll see lots of use-cases in real-life problems.
Hash Maps Hash Maps: HashMap&lt;K, V&gt;
You can’t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map">
  <meta itemprop="datePublished" content="2022-01-09T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-01-09T00:00:00+00:00">
  <meta itemprop="wordCount" content="1020">
  <meta itemprop="image" content="https://krshrimali.github.io/">
  <meta itemprop="keywords" content="Development,Coding,Rust,Notes">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://krshrimali.github.io/">
  <meta name="twitter:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta name="twitter:description" content="Chapter 8: Common Collections (Hash Maps) In the previous blog, I shared my notes on strings and vectors in Rust, and in this post we’ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we’ll see lots of use-cases in real-life problems.
Hash Maps Hash Maps: HashMap&lt;K, V&gt;
You can’t access using indices, but through keys. Hash Maps store data on heap. Hash Maps are homogenous (all keys must have same type, and all values must have same type). Use std::collections::HashMap to bring HashMap to scope. Creating a New Hash Map">





    <meta property="article:section" content="rust" />



    <meta property="article:published_time" content="2022-01-09 00:00:00 &#43;0000 UTC" />









    



    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://krshrimali.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                $ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://krshrimali.github.io/about">About</a></li><li><a href="https://krshrimali.github.io/posts">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        5 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">Common Collections (Vector and Strings) in Rust [Notes]</a>
      </h1>

      

      
        <hr />
        <aside id="toc">
          <div class="toc-title">Table of Contents</div>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#chapter-8-common-collections-hash-maps">Chapter 8: Common Collections (Hash Maps)</a></li>
    <li><a href="#hash-maps">Hash Maps</a></li>
    <li><a href="#hash-maps-and-ownership">Hash Maps and Ownership</a></li>
    <li><a href="#accessing-values-in-a-hash-map">Accessing Values in a Hash Map</a></li>
    <li><a href="#updating-a-hash-map">Updating a Hash Map</a></li>
    <li><a href="#hashing-functions">Hashing Functions</a></li>
    <li><a href="#note">Note</a></li>
  </ul>
</nav>
        </aside>
        <hr />

      

      <div class="post-content">
        <h2 id="chapter-8-common-collections-hash-maps">Chapter 8: Common Collections (Hash Maps)</h2>
<p>In the <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">previous blog</a>, I shared my notes on strings and vectors in Rust, and in this post we&rsquo;ll cover Hash Maps. I personally have found their use in competitive programming, a lot, but hopefully as we move on, we&rsquo;ll see lots of use-cases in real-life problems.</p>
<h2 id="hash-maps">Hash Maps</h2>
<p>Hash Maps: <code>HashMap&lt;K, V&gt;</code></p>
<ul>
<li>You can&rsquo;t access using indices, but through keys.</li>
<li>Hash Maps store data on heap.</li>
<li>Hash Maps are homogenous (all keys must have same type, and all values must have same type).</li>
<li>Use <code>std::collections::HashMap</code> to bring <code>HashMap</code> to scope.</li>
</ul>
<p><strong>Creating a New Hash Map</strong></p>
<p>First Way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now insert key, val pair
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>scores.insert(<span style="color:#e6db74">&#34;Kush&#34;</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>scores.insert(<span style="color:#e6db74">&#34;Kushashwa&#34;</span>, <span style="color:#ae81ff">10</span>);
</span></span></code></pre></div><p>Second Way: In case you have keys and values stored in two different vectors, and want to generate a hashmap from them, use <code>collect()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> teams <span style="color:#f92672">=</span> vec![String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> initial_scores <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Types will be infered by Rust from the data in the vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>_, _<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> teams.into_iter().zip(initial_scores.into_iter()).collect();
</span></span></code></pre></div><p>Why <code>HashMap&lt;_, _&gt;</code>? <code>collect()</code> method can store values into different datastructures, and we need to specify the type of <code>scores</code>. For the types of keys and values, Rust can infer the types itself - hence we specify <code>_</code>.</p>
<p>I was curious what <code>into_iter()</code> does, and <a href="https://stackoverflow.com/a/34745885">here</a> is a very interesting answer to <code>into_iter()</code> vs <code>iter()</code> on Stackoverflow. Someone mentioned <a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html/">this blog post</a> in the comments, I&rsquo;ve this as a TODO - but from the looks of it, it might be useful.</p>
<p>If you are curious what <code>teams.into_iter().zip(initial_scores.into_iter())</code> do? Great, check this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> teams <span style="color:#f92672">=</span> vec![String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> initial_scores <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tuple_output <span style="color:#f92672">=</span> teams.into_iter().zip(initial_scores.into_iter());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> item <span style="color:#66d9ef">in</span> tuple_output {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span> ,item.<span style="color:#ae81ff">0</span>, item.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Outputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>Blue, <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>Yellow, <span style="color:#ae81ff">50</span>
</span></span></code></pre></div><p>So clearly, creating a vector of tuples (of a <code>String</code> and <code>Integer</code>). Maybe try passing a vector of different length to <code>.zip()</code> function? ;)</p>
<h2 id="hash-maps-and-ownership">Hash Maps and Ownership</h2>
<p>Ownership is always the center of discussion when it comes to Rust. When you create a hashmap, and insert <code>String</code> objects, <code>i32</code> values, the ownership behaves differently:</p>
<ol>
<li>For types that implement <code>Copy</code> trait, like <code>i32</code>, the values will be copied to the hashmap.</li>
<li>For <code>String</code> values (owned values), the values are moved into the hashmap and the hashmap will be the owner.</li>
</ol>
<p>See the following example and corresponding error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    map.insert(str1, str2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, str1);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>   <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>  <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>         <span style="color:#f92672">----</span> <span style="color:#66d9ef">move</span> occurs because <span style="color:#960050;background-color:#1e0010">`</span>str1<span style="color:#960050;background-color:#1e0010">`</span> has <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>, which does not implement the <span style="color:#960050;background-color:#1e0010">`</span>Copy<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">trait</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8</span>  <span style="color:#f92672">|</span>     map.insert(str1, str2);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>                <span style="color:#f92672">----</span> value moved here
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">9</span>  <span style="color:#f92672">|</span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> <span style="color:#f92672">|</span>     println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, str1);
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">|</span>                    <span style="color:#f92672">^^^^</span> value borrowed here after <span style="color:#66d9ef">move</span>
</span></span></code></pre></div><p>As you can see, value was moved when <code>map.insert(str1, str2)</code> was called. One important point, that I&rsquo;ll just take from the book:</p>
<blockquote>
<p>If we insert references to values into the hash map, the values won’t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid.</p>
</blockquote>
<p>(This is covered in detail in Chapter 10, so let&rsquo;s save it for later).</p>
<h2 id="accessing-values-in-a-hash-map">Accessing Values in a Hash Map</h2>
<p>Use <code>&lt;HashMap&gt;.get(&lt;Key&gt;)</code> function to get the value corresponding to the key. Please note that it returns <code>Option&lt;&amp;V&gt;</code> where <code>V</code> is the type of the value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> str2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Name&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    map.insert(str1, str2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> val <span style="color:#f92672">=</span> map.get(<span style="color:#f92672">&amp;</span>String::from(<span style="color:#e6db74">&#34;Kush&#34;</span>));
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, val.unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Outputs: <code>Name</code>.</p>
<p>Since <code>map.get(&amp;String::from(&quot;Kush&quot;))</code> returns <code>Option&lt;&amp;String&gt;</code> object, we need to <code>unwrap()</code> it in order to print it. Here is <a href="https://www.ameyalokare.com/rust/2017/10/23/rust-options.html">an interesting post</a> on why using <code>unwrap()</code> is not the best idea, and what other options we have. I used <code>unwrap()</code> here, since I knew it is not <code>None</code>.</p>
<p>Iterating through a hash map is also easy in Rust:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Use the same code as above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (key, value) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>map {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, key, value);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Kush: Name
</span></span></span></code></pre></div><h2 id="updating-a-hash-map">Updating a Hash Map</h2>
<p>Note that you can only have one value corresponding to a key. Let&rsquo;s consider our options:</p>
<ol>
<li>
<p><strong>Overwriting a value</strong>: <code>insert()</code> twice, and the new value will replace the old value.</p>
</li>
<li>
<p><strong>Only insert if key has no value</strong>:</p>
<ul>
<li>Use <code>entry(&lt;Key&gt;)</code>, it returns an <code>Enum</code>: <code>Empty</code> (represents a value that might or might not exist).</li>
<li>Call <code>or_insert</code> on the enum, which inserts a value if key doesn&rsquo;t exist.</li>
<li><code>or_insert</code> returns a mutable reference to the value present, or to the new value inserted.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> scores <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    scores.insert(String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>), <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    scores.entry(String::from(<span style="color:#e6db74">&#34;Yellow&#34;</span>)).or_insert(<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>    scores.entry(String::from(<span style="color:#e6db74">&#34;Blue&#34;</span>)).or_insert(<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, scores);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Outputs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {&#34;Blue&#34;: 10, &#34;Yellow&#34;: 50}
</span></span></span></code></pre></div></li>
<li>
<p><strong>Updating a value based on the old value</strong>: Comments in the code should help explain the example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world wonderful world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// &#34;hello&#34;, &#34;world&#34;, &#34;wonderful&#34;, &#34;world&#34; - values of word
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> word <span style="color:#66d9ef">in</span> text.split_whitespace() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if the map has an entry for word, return the count of it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// else, insert 0 and increase the counter by 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// note that count is mutable reference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// so it needs to be de-referenced (in order to use it)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> map.entry(word).or_insert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, map); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Outputs:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// {&#34;world&#34;: 2, &#34;wonderful&#34;: 1, &#34;hello&#34;: 1}
</span></span></span></code></pre></div></li>
</ol>
<h2 id="hashing-functions">Hashing Functions</h2>
<p>By default, Hash Maps in Rust use <a href="https://en.wikipedia.org/wiki/SipHash"><code>SipHash</code></a> hashing function, but you can use your own as well - it should implement <code>BuildHasher</code> trait. More on this is discussed in Chapter 10.</p>
<p>That&rsquo;s it for Chapter 8, thank you for reading. :)</p>
<h2 id="note">Note</h2>
<hr>
<p>These are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone&rsquo;s and also my memory. At no point I say or mean that these should be preferred or read &ldquo;over&rdquo; the original resource mentioned. But as always, I&rsquo;m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).</p>
<hr>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://krshrimali.github.io/tags/development/">development</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/coding/">coding</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/rust/">rust</a></span>
        <span class="tag"><a href="https://krshrimali.github.io/tags/notes/">notes</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://krshrimali.github.io/categories/rust/">rust</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        1020 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2022-01-09 05:30 &#43;0530
        

         
          
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Common Collections (Vector and Strings) in Rust [Notes]</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://krshrimali.github.io/posts/2021/10/weekly-progress-report-03-10-2021-2/">
                    <span class="button__text">Weekly Progress Report: 03-10-2021, 2</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="https://krshrimali.github.io/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
