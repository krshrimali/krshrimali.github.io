<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Common Collections (Vector and Strings) in Rust [Notes] | Kushashwa Ravi Shrimali (Kush)</title>
<meta name="keywords" content="development, coding, rust, notes">
<meta name="description" content="Chapter 8: Common Collections
These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors
Vec&lt;T&gt; collection type discussed, aka vector:
* By default contiguous.
* All values should be of same type.
// Creation
let v: Vec&lt;i32&gt; = Vec::new();

// vec! macro for convenience
// default integer type is i32
let v = vec![1, 2, 3];

// Modifying
let mut v = Vec::new();
// Rust infers the type from the elements pushed here
v.push(5);
v.push(6);
// ...

// Dropping
// a vector is freed, when it goes out of scope
{
    let v = vec![1, 2, 3, 4];
    // ...
} // &lt;-- v goes out of scope here, and hence memory is freed as well

// Reading Elements of Vectors
let v = vec![1, 2, 3, 4, 5];
// First way:
let third: &amp;i32 = &amp;v[2];
println!(&#34;The third element is: {}&#34;, third);

// Second way:
match v.get(2) {
    Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num),
    None =&gt; println!(&#34;There is no third element.&#34;),
}
.get(&amp;index) method allows you to handle out of range errors.">
<meta name="author" content="map[name:Kushashwa Ravi Shrimali]">
<link rel="canonical" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
<link crossorigin="anonymous" href="https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://krshrimali.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://krshrimali.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://krshrimali.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://krshrimali.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://krshrimali.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
  <meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)">
  <meta property="og:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
  <meta property="og:description" content="Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors Vec&lt;T&gt; collection type discussed, aka vector: * By default contiguous. * All values should be of same type.
// Creation let v: Vec&lt;i32&gt; = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // &lt;-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: &amp;i32 = &amp;v[2]; println!(&#34;The third element is: {}&#34;, third); // Second way: match v.get(2) { Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num), None =&gt; println!(&#34;There is no third element.&#34;), } .get(&amp;index) method allows you to handle out of range errors.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-01-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-01-09T00:00:00+00:00">
    <meta property="article:tag" content="Development">
    <meta property="article:tag" content="Coding">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Common Collections (Vector and Strings) in Rust [Notes]">
<meta name="twitter:description" content="Chapter 8: Common Collections
These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.
8.1: Storing Lists of Values with Vectors
Vec&lt;T&gt; collection type discussed, aka vector:
* By default contiguous.
* All values should be of same type.
// Creation
let v: Vec&lt;i32&gt; = Vec::new();

// vec! macro for convenience
// default integer type is i32
let v = vec![1, 2, 3];

// Modifying
let mut v = Vec::new();
// Rust infers the type from the elements pushed here
v.push(5);
v.push(6);
// ...

// Dropping
// a vector is freed, when it goes out of scope
{
    let v = vec![1, 2, 3, 4];
    // ...
} // &lt;-- v goes out of scope here, and hence memory is freed as well

// Reading Elements of Vectors
let v = vec![1, 2, 3, 4, 5];
// First way:
let third: &amp;i32 = &amp;v[2];
println!(&#34;The third element is: {}&#34;, third);

// Second way:
match v.get(2) {
    Some(num) =&gt; println!(&#34;The third element is: {}&#34;, num),
    None =&gt; println!(&#34;There is no third element.&#34;),
}
.get(&amp;index) method allows you to handle out of range errors.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://krshrimali.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Common Collections (Vector and Strings) in Rust [Notes]",
      "item": "https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Common Collections (Vector and Strings) in Rust [Notes]",
  "name": "Common Collections (Vector and Strings) in Rust [Notes]",
  "description": "Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.\n8.1: Storing Lists of Values with Vectors Vec\u0026lt;T\u0026gt; collection type discussed, aka vector: * By default contiguous. * All values should be of same type.\n// Creation let v: Vec\u0026lt;i32\u0026gt; = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // \u0026lt;-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is: {}\u0026#34;, third); // Second way: match v.get(2) { Some(num) =\u0026gt; println!(\u0026#34;The third element is: {}\u0026#34;, num), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } .get(\u0026amp;index) method allows you to handle out of range errors.\n",
  "keywords": [
    "development", "coding", "rust", "notes"
  ],
  "articleBody": "Chapter 8: Common Collections These are my notes from the chapter-8 of rust book. Please scroll down to the bottom (Note) section if you are curious about what this is.\n8.1: Storing Lists of Values with Vectors Vec collection type discussed, aka vector: * By default contiguous. * All values should be of same type.\n// Creation let v: Vec\u003ci32\u003e = Vec::new(); // vec! macro for convenience // default integer type is i32 let v = vec![1, 2, 3]; // Modifying let mut v = Vec::new(); // Rust infers the type from the elements pushed here v.push(5); v.push(6); // ... // Dropping // a vector is freed, when it goes out of scope { let v = vec![1, 2, 3, 4]; // ... } // \u003c-- v goes out of scope here, and hence memory is freed as well // Reading Elements of Vectors let v = vec![1, 2, 3, 4, 5]; // First way: let third: \u0026i32 = \u0026v[2]; println!(\"The third element is: {}\", third); // Second way: match v.get(2) { Some(num) =\u003e println!(\"The third element is: {}\", num), None =\u003e println!(\"There is no third element.\"), } .get(\u0026index) method allows you to handle out of range errors.\nWhen a program has a valid reference, the borrow checker enforces the ownership and borrowing rules to ensure this reference and any other references to the contents of the vector remain valid.\nFollowing example will fail:\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026v[0]; v.push(6); println!(\"The first element is: {}\", first); Adding an element to a vector may require the old memory chunk to be transferred to a new space, causing old memory disallocation for the object v. Accessing \u0026v[0] can thus be dangerous, and hence the borrowing rules prevent programs from ending up in that situation. // Iterating over the values in a vector let v = vec![100, 32, 57]; // get immutable references to each element in a vector v for i in \u0026v { println!(\"{}\", i); } // get mutable references to each element in a mutable veector v let mut v = vec![100, 32, 57]; for i in \u0026mut v { *i += 50; } You can use an enum to store multiple type values in a vector, but indirectly, this is how:\nenum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12), ]; Note how row vector still has same types (of enum SpreadsheetCell) but can hold values of multiple types through enums.\n8.2: Storing UTF-8 Encoded Text with Strings In Rust, strings are implemented as a collection of bytes + some methods to provide useful functionality when those bytes are interpreted as text.\n(both types listed below are UTF-8 encoded)\nRust has only one string type in the core language: string slice str (usually seen in borrowed form: \u0026str). Rust’s standard library provides String type: (not coded into the core language): It’s growbable, mutable, and owned UTF-8 encoded string type. There are other string types included in Rust’s standard library: OsString, OsStr, CString, CStr\". Types ending with Stringrefer to owned variants, while types ending withStr` refer to borrowed variants. (not discussed in the book/chapter)\n// Creating a new string let mut s = String::new(); // If you have some initial data, use to_string method // this is available on any type that implements the Display trait // Following three methods are valid // First let data = \"initial contents\"; // a string literal let s = data.to_string(); // Second let s = \"initial conents\".to_string(); // Third let s = String::from(\"initial contents\"); // Updating a string let mut s = String::from(\"foo\"); s.push_str(\"bar\"); // s is now \"foobar\" // Appending to a string // using push_str and push let mut s = String::from(\"foo\"); s.push_str(\"bar\"); let mut s1 = String::from(\"foo\"); let s2 = \"bar\"; // We don't take ownership of s2 here // To ensure that we can still use s2 even after appending contents to s1 s1.push_str(s2); println!(\"s2 is {}\", s2); println!(\"s1 is {}\", s1); // Use push to append single character to the String let mut s = String::from(\"lo\"); s.push('l'); // now \"lol\" // Concatenation with + operator or the format! macro let s1 = String::from(\"Hello, \"); let s2 = String::from(\"world!\"); let s3 = s1 + \u0026s2; Consider the following script:\nlet s1 = String::from(\"foo\"); let s2 = String::from(\" bar\"); // The operation takes ownership of s1 here let s3 = s1 + \u0026s2; // You can not use s1 after the operation above println!(\"s3 is: {}\", s3); Following is the error you’ll get:\nerror[E0382]: borrow of moved value: `s1` --\u003e src/main.rs:5:27 | 2 | let s1 = String::from(\"foo\"); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 3 | let s2 = String::from(\" bar\"); 4 | let s3 = s1 + \u0026s2; | -- value moved here 5 | println!(\"s1 is: {}\", s1); | ^^ value borrowed here after move For more information about this error, try `rustc --explain E0382` So what’s happening? The + operator uses an add method whose signature looks like this for our inputs:\nfn add(self, s: \u0026str) -\u003e String { // ... } A few notes about s parameter:\nIt’s taken by reference. Means you add reference of the second string to the firstt string. You can not add 2 String values together, only \u0026str to a String. (Rust compiler, in our case, coerces the \u0026String argument into a \u0026str, more on deref coercion later). Note about self parameter:\nadd method takes ownership of self (it doesn’t have an \u0026). The point above implies, s1 will be moved to the add call and no longer be valid after that. let s3 = s1 + \u0026s2; The above statement actually:\nMoves s1 into the add call / takes ownership of s1 (making it invalid after that) Appends a copy of the contents of s2. Returns ownership of the result. (this process is more efficient than copying).\n// Concatenating multiple strings let s1 = String::from(\"tic\"); let s2 = String::from(\"tac\"); let s2 = String::from(\"toe\"); let s = s1 + \"-\" + \u0026s2 + \"-\" + \u0026s3; // You can also do: // Uses reference for all parameters, so no ownership of any here... let s = format!(\"{}-{}-{}\", s1, s2, s3); Talking about Indexing into Strings:\nThe following will give an error.\n// Indexing into Strings // Not like other languages (C++/Python): let s1 = String::from(\"hello\"); let h = s1[0]; Error:\nerror[E0277]: the type `String` cannot be indexed by `{integer}` --\u003e src/main.rs:3:13 | 3 | let h = s1[0]; | ^^^^^ `String` cannot be indexed by `{integer}` | = help: the trait `Index\u003c{integer}\u003e` is not implemented for `String` Rust strings don’t support indexing. To understand, let’s understand how memory storage works for strings in Rust.\nA String is a wrapper over a Vec. Consider:\n// Hola is 4 bytes long (each of the chars take 1 byte when encoded in UTF-8) and len will be 4 let hello = String::from(\"Hola\"); // Now consider: let hello = String::from(\"Здравствуйте\"); // Number of bytes stored for hello: 24 // Each unicode scalar value in the string above takes 2 bytes of storage. Hence, indexing into string’s bytes will not always correlate to a valid Unicode scalar value. Hence, no indexing support for strings in Rust.\nA final reason Rust doesn’t allow us to index into a String to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.\nSlicing strings:\nlet hello = \"Здравствуйте\"; // This will give you first 4 bytes of hello string let s = \u0026hello[0..4]; // In hello, every character is of 2 bytes, so s will have Зд With the same hello string, what will be the output if we used let s = \u0026hello[0..1];? Following error will be raised:\nthread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:3:13 Iterating over strings: use the chars method.\nfor c in \"नमस्ते\".chars() { println!(\"{}\", c); } // Output: // न // म // स // ् // त // े // bytes method will return each raw byte for b in \"नमस्ते\".bytes() { println!(\"{}\", b); } // Output: // All 18 bytes that made up this string // 224 // 164 // 168 // 224 // 164 // 174 // 224 // 164 // 184 // 224 // 165 // 141 // 224 // 164 // 164 // 224 // 165 // 135 Note: valid unicode scalar values maybe made up of more than 1 byte, like above.\nNote NOTE\nThese are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone’s and also my memory. At no point I say or mean that these should be preferred or read “over” the original resource mentioned. But as always, I’m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).\n",
  "wordCount" : "1535",
  "inLanguage": "en",
  "datePublished": "2022-01-09T00:00:00Z",
  "dateModified": "2022-01-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": {"name":"Kushashwa Ravi Shrimali"}
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kushashwa Ravi Shrimali (Kush)",
    "logo": {
      "@type": "ImageObject",
      "url": "https://krshrimali.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://krshrimali.github.io/" accesskey="h" title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://krshrimali.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://krshrimali.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://krshrimali.github.io/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://krshrimali.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://krshrimali.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Common Collections (Vector and Strings) in Rust [Notes]
    </h1>
    <div class="post-meta"><span title='2022-01-09 00:00:00 +0000 UTC'>January 9, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;map[name:Kushashwa Ravi Shrimali]

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#chapter-8-common-collections" aria-label="Chapter 8: Common Collections">Chapter 8: Common Collections</a><ul>
                        
                <li>
                    <a href="#81-storing-lists-of-values-with-vectors" aria-label="8.1: Storing Lists of Values with Vectors">8.1: Storing Lists of Values with Vectors</a></li>
                <li>
                    <a href="#82-storing-utf-8-encoded-text-with-strings" aria-label="8.2: Storing UTF-8 Encoded Text with Strings">8.2: Storing UTF-8 Encoded Text with Strings</a></li></ul>
                </li>
                <li>
                    <a href="#note" aria-label="Note">Note</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="chapter-8-common-collections">Chapter 8: Common Collections<a hidden class="anchor" aria-hidden="true" href="#chapter-8-common-collections">#</a></h2>
<p>These are my notes from the <a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html">chapter-8</a> of <a href="https://doc.rust-lang.org/book">rust book</a>. Please scroll down to the bottom (<code>Note</code>) section if you are curious about what this is.</p>
<h3 id="81-storing-lists-of-values-with-vectors">8.1: Storing Lists of Values with Vectors<a hidden class="anchor" aria-hidden="true" href="#81-storing-lists-of-values-with-vectors">#</a></h3>
<p><code>Vec&lt;T&gt;</code> collection type discussed, aka vector:
* By default contiguous.
* All values should be of same type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Creation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// vec! macro for convenience
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// default integer type is i32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Modifying
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Rust infers the type from the elements pushed here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>v.push(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>v.push(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Dropping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a vector is freed, when it goes out of scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">// &lt;-- v goes out of scope here, and hence memory is freed as well
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reading Elements of Vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// First way:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> third: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;The third element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, third);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Second way:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> v.get(<span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>    Some(num) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;The third element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, num),
</span></span><span style="display:flex;"><span>    None <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;There is no third element.&#34;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>.get(&amp;index)</code> method allows you to handle out of range errors.</p>
<blockquote>
<p>When a program has a valid reference, the borrow checker enforces the ownership and borrowing rules to ensure this reference and any other references to the contents of the vector remain valid.</p></blockquote>
<p>Following example will fail:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> first <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>v.push(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;The first element is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, first);
</span></span></code></pre></div><ul>
<li>Adding an element to a vector may require the old memory chunk to be transferred to a new space, causing old memory disallocation for the object <code>v</code>.</li>
<li>Accessing <code>&amp;v[0]</code> can thus be dangerous, and hence the borrowing rules prevent programs from ending up in that situation.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Iterating over the values in a vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// get immutable references to each element in a vector v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>v {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// get mutable references to each element in a mutable veector v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">57</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> v {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">50</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can use an <code>enum</code> to store multiple type values in a vector, but indirectly, this is how:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">SpreadsheetCell</span> {
</span></span><span style="display:flex;"><span>    Int(<span style="color:#66d9ef">i32</span>),
</span></span><span style="display:flex;"><span>    Float(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>    Text(String),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> row <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Int(<span style="color:#ae81ff">3</span>),
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Text(String::from(<span style="color:#e6db74">&#34;blue&#34;</span>)),
</span></span><span style="display:flex;"><span>    SpreadsheetCell::Float(<span style="color:#ae81ff">10.12</span>),
</span></span><span style="display:flex;"><span>];
</span></span></code></pre></div><p>Note how <code>row</code> vector still has same types (of <code>enum SpreadsheetCell</code>) but can hold values of multiple types through enums.</p>
<h3 id="82-storing-utf-8-encoded-text-with-strings">8.2: Storing UTF-8 Encoded Text with Strings<a hidden class="anchor" aria-hidden="true" href="#82-storing-utf-8-encoded-text-with-strings">#</a></h3>
<p>In Rust, strings are implemented as a collection of bytes + some methods to provide useful functionality when those bytes are interpreted as text.</p>
<p>(both types listed below are UTF-8 encoded)</p>
<ul>
<li>Rust has only one string type in the <strong>core language</strong>: string slice <code>str</code> (usually seen in borrowed form: <code>&amp;str</code>).</li>
<li>Rust&rsquo;s standard library provides <code>String</code> type: (not coded into the core language):
<ul>
<li>It&rsquo;s <em>growbable, mutable, and owned</em> UTF-8 encoded string type.</li>
</ul>
</li>
</ul>
<p>There are other string types included in Rust&rsquo;s standard library: <code>OsString, OsStr, CString, CStr&quot;. Types ending with </code>String<code>refer to owned variants, while types ending with</code>Str` refer to borrowed variants. (not discussed in the book/chapter)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Creating a new string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If you have some initial data, use to_string method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// this is available on any type that implements the Display trait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Following three methods are valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// First
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;initial contents&#34;</span>; <span style="color:#75715e">// a string literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> data.to_string();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;initial conents&#34;</span>.to_string();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Third
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;initial contents&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Updating a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push_str(<span style="color:#e6db74">&#34;bar&#34;</span>); <span style="color:#75715e">// s is now &#34;foobar&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Appending to a string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// using push_str and push
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push_str(<span style="color:#e6db74">&#34;bar&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bar&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We don&#39;t take ownership of s2 here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// To ensure that we can still use s2 even after appending contents to s1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>s1.push_str(s2);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;s2 is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s2);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;s1 is </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Use push to append single character to the String
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> s <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;lo&#34;</span>);
</span></span><span style="display:flex;"><span>s.push(<span style="color:#e6db74">&#39;l&#39;</span>); <span style="color:#75715e">// now &#34;lol&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Concatenation with + operator or the format! macro
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, &#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span></code></pre></div><p>Consider the following script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34; bar&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The operation takes ownership of s1 here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You can not use s1 after the operation above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;s3 is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s3);
</span></span></code></pre></div><p>Following is the error you&rsquo;ll get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0382]: <span style="color:#a6e22e">borrow</span> of moved value: <span style="color:#960050;background-color:#1e0010">`</span>s1<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">27</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>         <span style="color:#f92672">--</span> <span style="color:#66d9ef">move</span> occurs because <span style="color:#960050;background-color:#1e0010">`</span>s1<span style="color:#960050;background-color:#1e0010">`</span> has <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>, which does not implement the <span style="color:#960050;background-color:#1e0010">`</span>Copy<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">trait</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34; bar&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>              <span style="color:#f92672">--</span> value moved here
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span>     <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;s1 is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>                           <span style="color:#f92672">^^</span> value borrowed here after <span style="color:#66d9ef">move</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>For more information about this error, <span style="color:#66d9ef">try</span> <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">--</span>explain E0382<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p>So what&rsquo;s happening? The <code>+</code> operator uses an <code>add</code> method whose signature looks like this for our inputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>A few notes about <code>s</code> parameter:</p>
<ol>
<li>It&rsquo;s taken by reference. Means you add reference of the second string to the firstt string.</li>
<li>You can not add 2 <code>String</code> values together, only <code>&amp;str</code> to a <code>String</code>. (Rust compiler, in our case, coerces the <code>&amp;String</code> argument into a <code>&amp;str</code>, more on deref coercion later).</li>
</ol>
<p>Note about <code>self</code> parameter:</p>
<ol>
<li><code>add</code> method takes ownership of <code>self</code> (it doesn&rsquo;t have an <code>&amp;</code>).</li>
<li>The point above implies, <code>s1</code> will be moved to the <code>add</code> call and no longer be valid after that.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s3 <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2;
</span></span></code></pre></div><p>The above statement actually:</p>
<ol>
<li>Moves <code>s1</code> into the <code>add</code> call / takes ownership of <code>s1</code> (making it invalid after that)</li>
<li>Appends a <em>copy</em> of the contents of <code>s2</code>.</li>
<li>Returns ownership of the result.</li>
</ol>
<p>(this process is more efficient than copying).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Concatenating multiple strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;tic&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;tac&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;toe&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> s1 <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s2 <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You can also do:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Uses reference for all parameters, so no ownership of any here...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s1, s2, s3);
</span></span></code></pre></div><p>Talking about Indexing into Strings:</p>
<p>The following will give an error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Indexing into Strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Not like other languages (C++/Python):
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> s1[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>Error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>error[E0277]: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span> cannot be indexed by <span style="color:#960050;background-color:#1e0010">`</span>{integer}<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> h <span style="color:#f92672">=</span> s1[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>             <span style="color:#f92672">^^^^^</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span> cannot be indexed by <span style="color:#960050;background-color:#1e0010">`</span>{integer}<span style="color:#960050;background-color:#1e0010">`</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">=</span> help: <span style="color:#a6e22e">the</span> <span style="color:#66d9ef">trait</span> <span style="color:#960050;background-color:#1e0010">`</span>Index<span style="color:#f92672">&lt;</span>{integer}<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> is not implemented <span style="color:#66d9ef">for</span> <span style="color:#960050;background-color:#1e0010">`</span>String<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></div><p><em>Rust strings don&rsquo;t support indexing</em>. To understand, let&rsquo;s understand how memory storage works for strings in Rust.</p>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Consider:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Hola is 4 bytes long (each of the chars take 1 byte when encoded in UTF-8) and len will be 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hola&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now consider:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Здравствуйте&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Number of bytes stored for hello: 24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Each unicode scalar value in the string above takes 2 bytes of storage.
</span></span></span></code></pre></div><p>Hence, indexing into string&rsquo;s bytes will not always correlate to a valid Unicode scalar value. Hence, no indexing support for strings in Rust.</p>
<blockquote>
<p>A final reason Rust doesn’t allow us to index into a String to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</p></blockquote>
<p>Slicing strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Здравствуйте&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This will give you first 4 bytes of hello string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hello[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In hello, every character is of 2 bytes, so s will have Зд
</span></span></span></code></pre></div><p>With the same <code>hello</code> string, what will be the output if we used <code>let s = &amp;hello[0..1];</code>? Following error will be raised:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>thread <span style="color:#a6e22e">&#39;main&#39;</span> panicked at <span style="color:#a6e22e">&#39;byte</span> index <span style="color:#ae81ff">1</span> is not a <span style="color:#66d9ef">char</span> boundary; it is inside <span style="color:#e6db74">&#39;З&#39;</span> (bytes <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>) of <span style="color:#960050;background-color:#1e0010">`Здравствуйте`</span><span style="color:#a6e22e">&#39;</span>, src<span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">13</span>
</span></span></code></pre></div><p>Iterating over strings: use the <code>chars</code> method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;नमस्ते&#34;</span>.chars() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  न
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  म
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  स
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   ्
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  त
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   े
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// bytes method will return each raw byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> b <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;नमस्ते&#34;</span>.bytes() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// All 18 bytes that made up this string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 168
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 174
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 184
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 165
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 141
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 164
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 165
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 135
</span></span></span></code></pre></div><p>Note: valid unicode scalar values maybe made up of more than 1 byte, like above.</p>
<h2 id="note">Note<a hidden class="anchor" aria-hidden="true" href="#note">#</a></h2>
<hr>
<p><strong>NOTE</strong></p>
<p>These are just my notes, or things I write down while/after reading the chapters/blogs or going through resources. I like sharing them, for everyone&rsquo;s and also my memory. At no point I say or mean that these should be preferred or read &ldquo;over&rdquo; the original resource mentioned. But as always, I&rsquo;m open for feedback and/or suggestions, so feel free to comment here on the blog (just be nice, is all I ask for).</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://krshrimali.github.io/tags/development/">Development</a></li>
      <li><a href="https://krshrimali.github.io/tags/coding/">Coding</a></li>
      <li><a href="https://krshrimali.github.io/tags/rust/">Rust</a></li>
      <li><a href="https://krshrimali.github.io/tags/notes/">Notes</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-1/">
    <span class="title">« Prev</span>
    <br>
    <span>Porting a Tiling Window Manager Extenstion to C&#43;&#43; (Bismuth): Part-1</span>
  </a>
  <a class="next" href="https://krshrimali.github.io/posts/2022/01/common-collections-vector-and-strings-in-rust-notes/">
    <span class="title">Next »</span>
    <br>
    <span>Common Collections (Vector and Strings) in Rust [Notes]</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on x"
            href="https://x.com/intent/tweet/?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&amp;hashtags=development%2ccoding%2crust%2cnotes">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&amp;title=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;summary=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f&title=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on whatsapp"
            href="https://api.whatsapp.com/send?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on telegram"
            href="https://telegram.me/share/url?text=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common Collections (Vector and Strings) in Rust [Notes] on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Common%20Collections%20%28Vector%20and%20Strings%29%20in%20Rust%20%5bNotes%5d&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f01%2fcommon-collections-vector-and-strings-in-rust-notes%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
