<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) | Kushashwa Ravi Shrimali (Kush)</title><meta name=keywords content="development,coding,cpp,contributions,open source,KDE,Bismuth"><meta name=description content="Hi everyone! In this blog, I will be discussing the algorithm used in Bismuth to find the closest relative window to be focused for focusWindowByDirection event. If you haven&rsquo;t read the previous blog, make sure to give it a read here.
Recap from the previous blog
Let&rsquo;s start with a quick recap though, in the previous blog, we discussed:
focusWindowByDirection requires the following information:

direction (from the user) - can be one of: right, left, top/up, bottom/down.
activeWindow (from the current session) - this is needed since focusWindowByDirection event is a relative event to your current focused window.
Neighbor window candidates (neighborCandidates) to your current window (activeWindow) and the given direction (direction).

// declaration
std::vector<Window> Engine::getNeighborCandidates(const FocusDirection &amp;direction, const Window &amp;basisWindow);

// use
std::vector<Window> neighborCandidates = getNeighborCandidates(direction, basisWindow);

From these neighbor candidates (neighborCandidates), we will now find the closest relative window corner. To me, it was tricky to understand at first, so we&rsquo;ll be discussing this in detail over in the later sections.
Once we know the closest relative window corner, we&rsquo;ll try to find the window which satisfies the corner condition.
If there were multiple found, we&rsquo;ll return the first one based on the time-stamp (last used)

Understanding the scenario
I want to start off with a visual, took me some time to draw it, but in case it doesn&rsquo;t look good, I&rsquo;m sorry! My drawing teacher in the high school tried his best, but&mldr;"><meta name=author content="Kushashwa Ravi Shrimali"><link rel=canonical href=https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window/><link crossorigin=anonymous href=https://krshrimali.github.io/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://krshrimali.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://krshrimali.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://krshrimali.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://krshrimali.github.io/apple-touch-icon.png><link rel=mask-icon href=https://krshrimali.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://krshrimali.github.io/css/custom.css><meta property="og:url" content="https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window/"><meta property="og:site_name" content="Kushashwa Ravi Shrimali (Kush)"><meta property="og:title" content="Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window)"><meta property="og:description" content="Hi everyone! In this blog, I will be discussing the algorithm used in Bismuth to find the closest relative window to be focused for focusWindowByDirection event. If you haven’t read the previous blog, make sure to give it a read here.
Recap from the previous blog Let’s start with a quick recap though, in the previous blog, we discussed:
focusWindowByDirection requires the following information:
direction (from the user) - can be one of: right, left, top/up, bottom/down. activeWindow (from the current session) - this is needed since focusWindowByDirection event is a relative event to your current focused window. Neighbor window candidates (neighborCandidates) to your current window (activeWindow) and the given direction (direction). // declaration std::vector<Window> Engine::getNeighborCandidates(const FocusDirection &amp;direction, const Window &amp;basisWindow); // use std::vector<Window> neighborCandidates = getNeighborCandidates(direction, basisWindow); From these neighbor candidates (neighborCandidates), we will now find the closest relative window corner. To me, it was tricky to understand at first, so we’ll be discussing this in detail over in the later sections. Once we know the closest relative window corner, we’ll try to find the window which satisfies the corner condition. If there were multiple found, we’ll return the first one based on the time-stamp (last used) Understanding the scenario I want to start off with a visual, took me some time to draw it, but in case it doesn’t look good, I’m sorry! My drawing teacher in the high school tried his best, but…"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-31T00:00:00+00:00"><meta property="article:tag" content="Development"><meta property="article:tag" content="Coding"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Contributions"><meta property="article:tag" content="Open Source"><meta property="article:tag" content="KDE"><meta name=twitter:card content="summary"><meta name=twitter:title content="Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window)"><meta name=twitter:description content="Hi everyone! In this blog, I will be discussing the algorithm used in Bismuth to find the closest relative window to be focused for focusWindowByDirection event. If you haven&rsquo;t read the previous blog, make sure to give it a read here.
Recap from the previous blog
Let&rsquo;s start with a quick recap though, in the previous blog, we discussed:
focusWindowByDirection requires the following information:

direction (from the user) - can be one of: right, left, top/up, bottom/down.
activeWindow (from the current session) - this is needed since focusWindowByDirection event is a relative event to your current focused window.
Neighbor window candidates (neighborCandidates) to your current window (activeWindow) and the given direction (direction).

// declaration
std::vector<Window> Engine::getNeighborCandidates(const FocusDirection &amp;direction, const Window &amp;basisWindow);

// use
std::vector<Window> neighborCandidates = getNeighborCandidates(direction, basisWindow);

From these neighbor candidates (neighborCandidates), we will now find the closest relative window corner. To me, it was tricky to understand at first, so we&rsquo;ll be discussing this in detail over in the later sections.
Once we know the closest relative window corner, we&rsquo;ll try to find the window which satisfies the corner condition.
If there were multiple found, we&rsquo;ll return the first one based on the time-stamp (last used)

Understanding the scenario
I want to start off with a visual, took me some time to draw it, but in case it doesn&rsquo;t look good, I&rsquo;m sorry! My drawing teacher in the high school tried his best, but&mldr;"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://krshrimali.github.io/ accesskey=h title="Kushashwa Ravi Shrimali (Kush) (Alt + H)">Kushashwa Ravi Shrimali (Kush)</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://krshrimali.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://krshrimali.github.io/about title=About><span>About</span></a></li><li><a href=https://krshrimali.github.io/posts title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://krshrimali.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://krshrimali.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window)</h1><div class=post-meta><span title='2022-07-31 00:00:00 +0000 UTC'>July 31, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Kushashwa Ravi Shrimali</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#recap-from-the-previous-blog aria-label="Recap from the previous blog">Recap from the previous blog</a></li><li><a href=#understanding-the-scenario aria-label="Understanding the scenario">Understanding the scenario</a></li><li><a href=#getting-closest-relative-window-corner aria-label="Getting Closest Relative Window Corner">Getting Closest Relative Window Corner</a></li><li><a href=#getting-closest-relative-window aria-label="Getting Closest Relative Window">Getting Closest Relative Window</a></li><li><a href=#acknowledgement aria-label=Acknowledgement>Acknowledgement</a></li></ul></div></details></div><div class=post-content><p>Hi everyone! In this blog, I will be discussing the algorithm used in Bismuth to find the closest relative window to be focused for <code>focusWindowByDirection</code> event. If you haven&rsquo;t read the previous blog, make sure to give it a read <a href=https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-1/>here</a>.</p><h2 id=recap-from-the-previous-blog>Recap from the previous blog<a hidden class=anchor aria-hidden=true href=#recap-from-the-previous-blog>#</a></h2><p>Let&rsquo;s start with a quick recap though, in the previous blog, we discussed:</p><p><code>focusWindowByDirection</code> requires the following information:</p><ul><li><code>direction</code> (from the user) - can be one of: <code>right, left, top/up, bottom/down</code>.</li><li><code>activeWindow</code> (from the current session) - this is needed since <code>focusWindowByDirection</code> event is a <em>relative</em> event to your current focused window.</li><li>Neighbor window candidates (<code>neighborCandidates</code>) to your current window (<code>activeWindow</code>) and the given direction (<code>direction</code>).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// declaration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> Engine<span style=color:#f92672>::</span>getNeighborCandidates(<span style=color:#66d9ef>const</span> FocusDirection <span style=color:#f92672>&amp;</span>direction, <span style=color:#66d9ef>const</span> Window <span style=color:#f92672>&amp;</span>basisWindow);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> neighborCandidates <span style=color:#f92672>=</span> getNeighborCandidates(direction, basisWindow);
</span></span></code></pre></div><ul><li>From these neighbor candidates (<code>neighborCandidates</code>), we will now find the closest relative window corner. To me, it was tricky to understand at first, so we&rsquo;ll be discussing this in detail over in the later sections.</li><li>Once we know the closest relative window corner, we&rsquo;ll try to find the window which satisfies the corner condition.</li><li>If there were multiple found, we&rsquo;ll return the first one based on the time-stamp (last used)</li></ul><h2 id=understanding-the-scenario>Understanding the scenario<a hidden class=anchor aria-hidden=true href=#understanding-the-scenario>#</a></h2><p>I want to start off with a visual, took me some time to draw it, but in case it doesn&rsquo;t look good, I&rsquo;m sorry! My drawing teacher in the high school tried his best, but&mldr;</p><p><img loading=lazy src=https://raw.githubusercontent.com/krshrimali/blog/main/assets/blogs/bismuth-part-2-window-alignment.png></p><p>Above image is visual of a tiling window layout where there are in total 5 windows opened (just for imagination, no sane person would open these many windows on a 24 inch monitor&mldr; xD): <code>A, B, C, D, E</code>, where as mentioned in the figure above, <code>E</code> is the active window and we are trying to focus <code>UP</code>. A few notes to take from the figure:</p><ol><li><code>A, B, C, D</code> windows are of same height and width <code>w</code> and <code>h</code>. We&rsquo;ll use this information later.</li><li><code>E</code> window is the active window with width: <code>2 * w</code> and height: <code>h</code>.</li><li>We are trying to focus <code>UP</code>.</li></ol><h2 id=getting-closest-relative-window-corner>Getting Closest Relative Window Corner<a hidden class=anchor aria-hidden=true href=#getting-closest-relative-window-corner>#</a></h2><p>In the <a href=https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-1/>previous blog</a>, we had covered <code>getNeighborCandidates</code>, the output here would be windows: <code>A, B, C, D</code>. The order will not matter here for understanding, so don&rsquo;t worry about that.</p><p>The next steps in the code include:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> closestRelativeWindowCorner <span style=color:#f92672>=</span> getClosestRelativeWindowCorner(direction, neighborCandidates);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> closestWindows <span style=color:#f92672>=</span> getClosestRelativeWindow(direction, neighborCandidates, getClosestRelativeWindow);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>most_recently_used</span>(closestWindows);
</span></span></code></pre></div><p>I didn&rsquo;t add comments here, because we&rsquo;ll be going through these 2 magic functions below. Let&rsquo;s start with <code>getClosestRelativeWindowCorner</code>. The source code for the definition of this function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> Engine<span style=color:#f92672>::</span>getClosestRelativeWindowCorner(<span style=color:#66d9ef>const</span> Engine<span style=color:#f92672>::</span>FocusDirection <span style=color:#f92672>&amp;</span>direction, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>neighbors)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>reduce(neighbors.cbegin(),
</span></span><span style=display:flex><span>                       neighbors.cend(),
</span></span><span style=display:flex><span>                       <span style=color:#75715e>/* initial value */</span> direction <span style=color:#f92672>==</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Up <span style=color:#f92672>||</span> direction <span style=color:#f92672>==</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Left <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> INT_MAX,
</span></span><span style=display:flex><span>                       [<span style=color:#f92672>&amp;</span>](<span style=color:#66d9ef>int</span> prevValue, <span style=color:#66d9ef>const</span> Window <span style=color:#f92672>&amp;</span>window) {
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>switch</span> (direction) {
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Up:
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>max(window.geometry().bottom(), prevValue);
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Down:
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>min(window.geometry().y(), prevValue);
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Left:
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>max(window.geometry().right(), prevValue);
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Right:
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>min(window.geometry().x(), prevValue);
</span></span><span style=display:flex><span>                           }
</span></span><span style=display:flex><span>                       });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Don&rsquo;t worry about the code if it confuses you, keep in mind that we have the direction as <code>Engine::FocusDirection::Up</code>, and <code>neighbors</code> as <code>{A, B, C, D}</code>. This function gets you the closest window corner relative to the active window or the basis window. How would you do that? Well, it will depend on the direction.</p><p>If the direction is <code>Up</code> or <code>Down</code> &ndash;> you should compare the <code>y</code> coordinate.
If the direction is <code>Left</code> or <code>Right</code> &ndash;> you should compare the <code>x</code> coordinate.</p><p>Now remember the mathematics lectures you had way back in the high school, if you wanna focus up, which vertex do you really care about? Keep your focus on the window C and E for once, the comparison should definitely be with the bottom right&rsquo;s y coordinate, right? That&rsquo;s what we do here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Up: 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>max(window.geometry().bottom(), prevValue);
</span></span></code></pre></div><p>A quick look at <code>bottom()</code> source code in <code>qrect.h</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Q_DECL_CONSTEXPR <span style=color:#66d9ef>inline</span> QRect<span style=color:#f92672>::</span>bottom() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span> { <span style=color:#66d9ef>return</span> y2; }
</span></span></code></pre></div><p>Where <code>y2</code> is the bottom right&rsquo;s y coordinate. Since we are going up, and anything above the basis window should have <code>y</code> value &lt; basis window&rsquo;s <code>y</code> value. (The top left of any screen is considered to be <code>(0, 0)</code> in this blog). Hence we set the initial value as <code>0</code>. If we had to go down, we&rsquo;ll set it to <code>INT_MAX</code> as for anything below the basis window, we&rsquo;ll use <code>std::min</code> and hence <code>INT_MAX</code> will fade away with each neighbor window.</p><p>Anyways, enough of theory, so what will be the output of this function for our scenario? Well, this function will give us <code>y_C + h</code> (which is equal to <code>y_D + h</code>, so any of them is fine). Now, we&rsquo;ll go ahead to the next function.</p><h2 id=getting-closest-relative-window>Getting Closest Relative Window<a hidden class=anchor aria-hidden=true href=#getting-closest-relative-window>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> getClosestRelativeWindow(<span style=color:#66d9ef>const</span> Engine<span style=color:#f92672>::</span>FocusDirection <span style=color:#f92672>&amp;</span>direction, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>windowArray, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>closestPoint)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Window<span style=color:#f92672>&gt;</span> result;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>copy_if(windowArray.cbegin(), windowArray.cend(), result.begin(), [<span style=color:#f92672>&amp;</span>](<span style=color:#66d9ef>const</span> Window <span style=color:#f92672>&amp;</span>window) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (direction) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Up:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window.geometry().bottom() <span style=color:#f92672>&gt;</span> closestPoint <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Down:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window.geometry().y() <span style=color:#f92672>&lt;</span> closestPoint <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Left:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window.geometry().right() <span style=color:#f92672>&gt;</span> closestPoint <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Engine<span style=color:#f92672>::</span>FocusDirection<span style=color:#f92672>::</span>Right:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window.geometry().x() <span style=color:#f92672>&lt;</span> closestPoint <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again, remember, we have <code>direction</code> as <code>Engine::FocusDirection::Up</code>, <code>windowArray</code> as <code>{A, B, C, D}</code>, and <code>closestPoint</code> as <code>y_C + h</code> value.</p><p>This function only exists to give you <em>all the windows</em> which are <em>close enough</em> to the <code>closestPoint</code>. The output out of this function will be windows <code>C, D</code> (reminder: <code>E</code> is the basis or active window).</p><p>Some will wonder why do we have two functions: <code>getClosestRelativeWindowCorner</code>, and <code>getClosestRelativeWindow</code>? And why this <code>-5, +5</code>? Unfortunately, it&rsquo;s possible that some windows aren&rsquo;t tiled properly, see <a href=https://github.com/Bismuth-Forge/bismuth/issues/102>this</a> issue. I&rsquo;ve attached the screenshot: (credits to the author)</p><p><img loading=lazy src=https://user-images.githubusercontent.com/13597663/136797590-9c525224-6421-4384-ad42-4de54a814cb2.png></p><p>Hence we can&rsquo;t be too strict here. I personally believe this number <code>+/- 5</code> should be tinkered better and not hard-coded, but that&rsquo;s for later.</p><p>So from <code>A, B, C, D</code> being the <em>neighbor candidates</em>, we have <code>C, D</code> as the final <em>closest windows</em> to the basis window (<code>E</code>). Now which one to choose? That&rsquo;s where we&rsquo;ll have to store the timestamps for each window. And this timestamp should record the last time it was used or accessed. We just get the most recently used out of these windows, and I&rsquo;ll be discussing in the future blogs. I think we discussed a lot today. So that should be it&mldr;</p><h2 id=acknowledgement>Acknowledgement<a hidden class=anchor aria-hidden=true href=#acknowledgement>#</a></h2><p>I don&rsquo;t want to shy away from thanking the main maintainer of Bismuth, <a href=https://github.com/gikari>gikari</a> who has worked pro-actively on Bismuth. Of course, the credits should also go to <a href=https://github.com/esjeon/krohnkite>krohnkite</a> for the hard work they put in.</p><p>In case anyone has a feedback or suggestion, please leave a comment on this blog. I wish everyone good health and success. Thanks for reading &lt;3</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://krshrimali.github.io/tags/development/>Development</a></li><li><a href=https://krshrimali.github.io/tags/coding/>Coding</a></li><li><a href=https://krshrimali.github.io/tags/cpp/>Cpp</a></li><li><a href=https://krshrimali.github.io/tags/contributions/>Contributions</a></li><li><a href=https://krshrimali.github.io/tags/open-source/>Open Source</a></li><li><a href=https://krshrimali.github.io/tags/kde/>KDE</a></li><li><a href=https://krshrimali.github.io/tags/bismuth/>Bismuth</a></li></ul><nav class=paginav><a class=prev href=https://krshrimali.github.io/posts/2022/09/applying-for-research-internships-universities/><span class=title>« Prev</span><br><span>Applying for Research Internships (Universities)</span>
</a><a class=next href=https://krshrimali.github.io/posts/2022/07/porting-a-tiling-window-manager-extenstion-to-c-bismuth-part-1/><span class=title>Next »</span><br><span>Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on x" href="https://x.com/intent/tweet/?text=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f&amp;hashtags=development%2ccoding%2ccpp%2ccontributions%2copensource%2cKDE%2cBismuth"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f&amp;title=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29&amp;summary=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29&amp;source=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f&title=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on whatsapp" href="https://api.whatsapp.com/send?text=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29%20-%20https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on telegram" href="https://telegram.me/share/url?text=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29&amp;url=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Porting a Tiling Window Manager Extenstion to C++ (Bismuth): Part-2 (getting closest relative window) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Porting%20a%20Tiling%20Window%20Manager%20Extenstion%20to%20C%2b%2b%20%28Bismuth%29%3a%20Part-2%20%28getting%20closest%20relative%20window%29&u=https%3a%2f%2fkrshrimali.github.io%2fposts%2f2022%2f07%2fporting-a-tiling-window-manager-extenstion-to-c-bismuth-part-2-getting-closest-relative-window%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>