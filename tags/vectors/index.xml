<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Vectors on Kushashwa Ravi Shrimali (Kush)</title><link>https://krshrimali.github.io/tags/vectors/</link><description>Recent content in Vectors on Kushashwa Ravi Shrimali (Kush)</description><generator>Hugo -- 0.148.2</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 26 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://krshrimali.github.io/tags/vectors/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding how Vectors work in C++ (Part-2): What happens when you initialize a vector?</title><link>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-2-what-happens-when-you-initialize-a-vector/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-2-what-happens-when-you-initialize-a-vector/</guid><description>&lt;p>In the last blog post, I realized there were a lot of methods inherited from the base struct &lt;code>_Vector_base_&lt;/code> and &lt;code>_Vector_impl_data&lt;/code>. Instead of directly going to the source code of these structs, I&amp;rsquo;ll go through their methods and objects by explaining what happens when we initialize a vector.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Vector-Part-2.png">&lt;/p>
&lt;p>That is, we will start from calling a vector constructor and then see how memory is allocated. If you haven&amp;rsquo;t looked at the previous blog post, please take a look &lt;a href="https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-1-how-does-push_back-work/">here&lt;/a>. I want to be thorough with the blog post, so I&amp;rsquo;ll divide this into multiple posts. By the end of this post, you&amp;rsquo;ll go through the following structs:&lt;/p></description></item><item><title>Understanding how Vectors work in C++ (Part-3): Diving deep into member functions of vectors</title><link>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-3-diving-deep-into-member-functions-of-vectors/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-3-diving-deep-into-member-functions-of-vectors/</guid><description>&lt;p>In this blog, we&amp;rsquo;ll continue diving deep into the source code of Vector Containers in GCC compiler. Today, we will be discussing some of the most commonly used methods of vectors, and how they are implemented.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Vector-Part-3.png">&lt;/p>
&lt;p>Before we start, if you haven&amp;rsquo;t looked at the previous blogs in the C++ series, please take a look &lt;a href="https://krshrimali.github.io/categories/cpp/">here&lt;/a>. If you are already familiar with memory allocation in vector containers and vector&amp;rsquo;s base structs, then you can skip reading the previous blogs and continue here. If not, I suggest you reading them.&lt;/p></description></item><item><title>Understanding how Vectors work in C++ (Part-1): How does push_back work?</title><link>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-1-how-does-push_back-work/</link><pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-1-how-does-push_back-work/</guid><description>&lt;p>This blog is focused to explain how vectors work in the backend, and we&amp;rsquo;ll specially look at &lt;code>push_back&lt;/code> method of the vector container. Looking at the source code helps to understand the implementation, and how vectors can be used efficiently.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Vector-Part-1.png">&lt;/p>
&lt;p>Vector Containers are type of sequenced containers in C++ commonly uses as a better alternative of arrays. They are also known as dynamic arrays, and as the term suggests - it&amp;rsquo;s one of the advantages they hold over native arrays in C++. You might have heard of Standard Library containers like &lt;code>vector&lt;/code>, &lt;code>set&lt;/code>, &lt;code>queue&lt;/code>, &lt;code>priority_queue&lt;/code> before. They all implement methods defined by the Container Concept.&lt;/p></description></item></channel></rss>