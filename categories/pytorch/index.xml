<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Pytorch on Kushashwa Ravi Shrimali (Kush)</title><link>https://krshrimali.github.io/categories/pytorch/</link><description>Recent content in Pytorch on Kushashwa Ravi Shrimali (Kush)</description><generator>Hugo -- 0.147.8</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 15 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://krshrimali.github.io/categories/pytorch/index.xml" rel="self" type="application/rss+xml"/><item><title>Releasing Docker Container and Binder for using Xeus-Cling, Libtorch and OpenCV in C++</title><link>https://krshrimali.github.io/posts/2020/09/releasing-docker-container-and-binder-for-using-xeus-cling-libtorch-and-opencv-in-c-/</link><pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2020/09/releasing-docker-container-and-binder-for-using-xeus-cling-libtorch-and-opencv-in-c-/</guid><description>&lt;p>Today, I am elated to share Docker image for &lt;code>OpenCV&lt;/code>, &lt;code>Libtorch&lt;/code> and &lt;code>Xeus-Cling&lt;/code>. We&amp;rsquo;ll discuss how to use the &lt;code>dockerfile&lt;/code> and &lt;code>binder&lt;/code>.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-Docker-Binder.jpg">&lt;/p>
&lt;p>Before I move on, the credits for creating and maintaining Docker image goes to &lt;a href="https://github.com/vishwesh5">Vishwesh Ravi Shrimali&lt;/a>. He has been working on some cool stuff, please do get in touch with him if you&amp;rsquo;re interested to know.&lt;/p>
&lt;p>First question in your mind would be, &lt;strong>Why use Docker or Binder?&lt;/strong> The answer to it lies in the frequency of queries on &lt;a href="http://www.discuss.pytorch.org">the discussion forum of PyTorch&lt;/a> and Stackoverflow on &lt;strong>Installation of Libtorch with OpenCV in Windows/Linux/OSX&lt;/strong>. I&amp;rsquo;ve had nightmares setting up the Windows system myself for &lt;code>Libtorch&lt;/code> and nothing could be better than using &lt;code>Docker&lt;/code>. Read on, to know why.&lt;/p></description></item><item><title>[Training and Results] Deep Convolutional Generative Adversarial Networks on CelebA Dataset using PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2020/02/training-and-results-deep-convolutional-generative-adversarial-networks-on-celeba-dataset-using-pytorch-c-api/</link><pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2020/02/training-and-results-deep-convolutional-generative-adversarial-networks-on-celeba-dataset-using-pytorch-c-api/</guid><description>&lt;p>It&amp;rsquo;s been around 5 months since I released my last blog on &lt;a href="https://krshrimali.github.io/posts/2019/09/deep-convolutional-generative-adversarial-networks-review-and-implementation-using-pytorch-c-api/">DCGAN Review and Implementation using PyTorch C++ API&lt;/a> and I&amp;rsquo;ve missed writing blogs badly! Straight the to the point, I&amp;rsquo;m back!&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-DCGAN-2.jpg">&lt;/p>
&lt;p>But before we start, the PyTorch C++ Frontend has gone through several changes and thanks to the awesome contributors around the world, it resembles the Python API more than it ever did! Since a lot of things have changed, I have also updated my previous blogs (tested on 1.4 Stable build).&lt;/p></description></item><item><title>Deep Convolutional Generative Adversarial Networks: Review and Implementation using PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2019/09/deep-convolutional-generative-adversarial-networks-review-and-implementation-using-pytorch-c-api/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/09/deep-convolutional-generative-adversarial-networks-review-and-implementation-using-pytorch-c-api/</guid><description>&lt;p>I&amp;rsquo;m pleased to start a series of blogs on GANs and their implementation with PyTorch C++ API. We&amp;rsquo;ll be starting with one of the initial GANs - DCGANs (Deep Convolutional Generative Adversarial Networks).&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-DCGAN.jpg">&lt;/p>
&lt;p>The authors (Soumith Chintala, Radford and Luke Metz) in &lt;a href="https://arxiv.org/pdf/1511.06434.pdf">this&lt;/a> Seminal Paper on DCGANs introduced DCGANs to the world like this:&lt;/p>
&lt;blockquote>
&lt;p>We introduce a class of CNNs called deep convolutional generative adversarial networks (DCGANs), that have certain architectural constraints, and demonstrate that they are a strong candidate for unsupervised learning. Training on various image datasets, we show convincing evidence that our deep convolutional adversarial pair learns a hierarchy of representations from object parts to scenes in both the generator and discriminator. Additionally, we use the learned features for novel tasks - demonstrating their applicability as general image representations.&lt;/p></description></item><item><title>Setting up Jupyter Notebook (Xeus Cling) for Libtorch and OpenCV Libraries</title><link>https://krshrimali.github.io/posts/2019/08/setting-up-jupyter-notebook-xeus-cling-for-libtorch-and-opencv-libraries/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/08/setting-up-jupyter-notebook-xeus-cling-for-libtorch-and-opencv-libraries/</guid><description>&lt;h2 id="introduction-to-xeus-cling">Introduction to Xeus Cling&lt;/h2>
&lt;p>Today, we are going to run our C++ codes in the Jupyter Notebook. Sounds ambitious? Not much. Let&amp;rsquo;s see how we do it using Xeus Cling.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-Xeus-Cling.jpg">&lt;/p>
&lt;p>I&amp;rsquo;ll quote the definition of Xeus Cling on the official &lt;a href="https://xeus-cling.readthedocs.io/en/latest/#targetText=xeus%2Dcling%20is%20a%20Jupyter,of%20the%20Jupyter%20protocol%20xeus">documentation website&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>xeus-cling is a Jupyter kernel for C++ based on the C++ interpreter cling and the native implementation of the Jupyter protocol xeus.&lt;/p>&lt;/blockquote>
&lt;p>Just like we use Python Kernel in the Jupyter Notebook, we can also use a C++ based interpreter cling combined with a Jupyter protocol called Xeus to reach closer to implementing C++ code in the notebook.&lt;/p></description></item><item><title>Applying Transfer Learning on Dogs vs Cats Dataset (ResNet18) using PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2019/08/applying-transfer-learning-on-dogs-vs-cats-dataset-resnet18-using-pytorch-c-api/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/08/applying-transfer-learning-on-dogs-vs-cats-dataset-resnet18-using-pytorch-c-api/</guid><description>&lt;h2 id="transfer-learning">Transfer Learning&lt;/h2>
&lt;p>&amp;ndash;
Before we go ahead and discuss the &lt;strong>Why&lt;/strong> question of Transfer Learning, let&amp;rsquo;s have a look at &lt;strong>What is Transfer Learning?&lt;/strong> Let&amp;rsquo;s have a look at the &lt;a href="http://cs231n.github.io/transfer-learning">Notes&lt;/a> from CS231n on Transfer Learning:&lt;/p>
&lt;blockquote>
&lt;p>In practice, very few people train an entire Convolutional Network from scratch (with random initialization), because it is relatively rare to have a dataset of sufficient size. Instead, it is common to pretrain a ConvNet on a very large dataset (e.g. ImageNet, which contains 1.2 million images with 1000 categories), and then use the ConvNet either as an initialization or a fixed feature extractor for the task of interest.&lt;/p></description></item><item><title>Classifying Dogs vs Cats using PyTorch C++: Part 2</title><link>https://krshrimali.github.io/posts/2019/07/classifying-dogs-vs-cats-using-pytorch-c-part-2/</link><pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/07/classifying-dogs-vs-cats-using-pytorch-c-part-2/</guid><description>&lt;p>In the last blog, we had discussed all but training and results of our custom CNN network on Dogs vs Cats dataset. Today, we&amp;rsquo;ll be making some small changes in the network and discussing training and results of the task.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Classify-Dogs-Cats-Blog-05.jpg">&lt;/p>
&lt;p>I&amp;rsquo;ll start with the network overview again, where we used a network similar to VGG-16 (with one extra Fully Connected Layer in the end). While there are absolutely no problems with that network, but since the dataset contains a lot of images (25000 in training dataset) and we were using (200x200x3) input shape to the network (which is 120,000 floating point numbers), this leads to high memory consumption. In short, I was out of RAM to store these many images during program execution.&lt;/p></description></item><item><title>Classifying Dogs vs Cats using PyTorch C++ API: Part-1</title><link>https://krshrimali.github.io/posts/2019/07/classifying-dogs-vs-cats-using-pytorch-c-api-part-1/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/07/classifying-dogs-vs-cats-using-pytorch-c-api-part-1/</guid><description>&lt;p>Hi Everyone! So excited to be back with another blog in the series of PyTorch C++ Blogs.&lt;/p>
&lt;p>Today, we are going to see a practical example of applying a CNN to a Custom Dataset - Dogs vs Cats. This is going to be a short post of showing results and discussion about hyperparameters and loss functions for the task, as code snippets and explanation has been provided &lt;a href="https://krshrimali.github.io/Training-Network-Using-Custom-Dataset-PyTorch-CPP/">here&lt;/a>, &lt;a href="https://krshrimali.github.io/Custom-Data-Loading-Using-PyTorch-CPP-API/">here&lt;/a> and &lt;a href="https://krshrimali.github.io/PyTorch-C&amp;#43;&amp;#43;-API/">here&lt;/a>.&lt;/p>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-Dogs-Cats.jpg">&lt;/p></description></item><item><title>Training a Network on Custom Dataset using PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2019/07/training-a-network-on-custom-dataset-using-pytorch-c-api/</link><pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/07/training-a-network-on-custom-dataset-using-pytorch-c-api/</guid><description>&lt;h2 id="recap-of-the-last-blog">Recap of the last blog&lt;/h2>
&lt;p>Before we move on, it&amp;rsquo;s important what we covered in the last blog. We&amp;rsquo;ll be going forward from loading Custom Dataset to now using the dataset to train our VGG-16 Network. Previously, we were able to load our custom dataset using the following template:&lt;/p></description></item><item><title>Announcing a series of blogs on PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2019/07/announcing-a-series-of-blogs-on-pytorch-c-api/</link><pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/07/announcing-a-series-of-blogs-on-pytorch-c-api/</guid><description>&lt;p>&lt;strong>I&amp;rsquo;m happy to announce a Series of Blog Posts on PyTorch C++ API&lt;/strong>. Check out the blogs in the series &lt;a href="https://krshrimali.github.io/categories/pytorch/">here&lt;/a>.&lt;/p>
&lt;p>Happy Reading!&lt;/p></description></item><item><title>Custom Data Loading using PyTorch C++ API</title><link>https://krshrimali.github.io/posts/2019/07/custom-data-loading-using-pytorch-c-api/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://krshrimali.github.io/posts/2019/07/custom-data-loading-using-pytorch-c-api/</guid><description>&lt;h2 id="overview-how-c-api-loads-data">Overview: How C++ API loads data?&lt;/h2>
&lt;p>&lt;img loading="lazy" src="https://raw.githubusercontent.com/krshrimali/blog/main/assets/cover-images/Cover-Custom-Data.png">&lt;/p>
&lt;p>In the last blog, we discussed application of a VGG-16 Network on MNIST Data. For those, who are reading this blog for the first time, here is how we had loaded MNIST data:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> data_loader &lt;span style="color:#f92672">=&lt;/span> torch&lt;span style="color:#f92672">::&lt;/span>data&lt;span style="color:#f92672">::&lt;/span>make_data_loader&lt;span style="color:#f92672">&amp;lt;&lt;/span>torch&lt;span style="color:#f92672">::&lt;/span>data&lt;span style="color:#f92672">::&lt;/span>samplers&lt;span style="color:#f92672">::&lt;/span>SequentialSampler&lt;span style="color:#f92672">&amp;gt;&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>move(torch&lt;span style="color:#f92672">::&lt;/span>data&lt;span style="color:#f92672">::&lt;/span>datasets&lt;span style="color:#f92672">::&lt;/span>MNIST(&lt;span style="color:#e6db74">&amp;#34;../../data&amp;#34;&lt;/span>).map(torch&lt;span style="color:#f92672">::&lt;/span>data&lt;span style="color:#f92672">::&lt;/span>transforms&lt;span style="color:#f92672">::&lt;/span>Normalize&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(&lt;span style="color:#ae81ff">0.13707&lt;/span>, &lt;span style="color:#ae81ff">0.3081&lt;/span>))).map(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> torch&lt;span style="color:#f92672">::&lt;/span>data&lt;span style="color:#f92672">::&lt;/span>transforms&lt;span style="color:#f92672">::&lt;/span>Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>()), &lt;span style="color:#ae81ff">64&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s break this piece by piece, as for beginners, this may be unclear. First, we ask the C++ API to load data (images and labels) into tensors.&lt;/p></description></item></channel></rss>